## 問題名
飛車と角の利き
## キーワード
シミュレーション
## 概要
将棋盤の任意のマスに角と飛車のみ一つずつ異なる座標に置いたとき、それらが移動できる範囲を数え上げる。1マス＝1としてカウント
## 方針と読解
飛車を置いたあと異なる座標に角を置いて、それぞれの配置ごとにカウントしていくだけ。とくに方針はない。<br>
一辺が9マスで飛車角それぞれなのでO(9^4)くらい？反転や鏡像を考えれば高速化できそうだがめんどいので全探索でいい
## 参考
特に無い。
## 所感

```
var hsteps = new int[]{0, 1, 0, -1, 0};
for(int p=0; p<4; p++){
  int chi = hi+hsteps[p], chj = hj+hsteps[p+1];
}
```
上下左右の移動だとよくこれ使うんだけど、ナナメはやったことなかった。数秒考えればわかるけど
```
var ksteps = new int[]{-1, 1, 1, -1, -1};
```
で同じようにできるのでいっそ1ループ内で一緒にマップを更新していった。<br>
あと配列をクリアするスマートな方法がわからなかったので無理やりnewした。無駄に重くしてる感じがある
