## atcoder
### ABC
#### 003
C
- 条件から、所与の配列の要素の最大値を越えることはない。最低で`(0+max(a))/2`になる
- 最大値は、とうぜんいまのやつの0が大きければ大きいほどいい（xとするとx<=max(a)となるx）
- それを探す。
- 問題文を読んでなくてなにげにK個という条件を忘れていて、手元でサンプルがWAになったので愚直に大きい順にK個取ってそれを小さい方から`ans=(ans+A[i])//2`していく作業

#### 004
C
- 30回でもとの配列に戻るってのは見てたら2秒で浮かぶのでそれで丸めた範囲だけやる
- はい
 - 独自に余りをだしたらふつうにバグを埋め込んでしまったが問題文通り`mod 5`しましょう
  - `(i-1)%5`とかしててループしてしまってあぼーんなった(わかりづらい)
  - goで解いてみた
    ```go
    tes := makeRange(1, 6)
  	n := nextInt() % 30
	  for i := 0; i < n; i++ {
  		tes[i%5], tes[i%5+1] = tes[i%5+1], tes[i%5]
	  }
  	PrintOut(tes, "")
    ```
#### 005
C
- 4回目の挑戦で足掛け半年くらいらしいが解けた
  - 今までどんなやり方をしてたかは見てない
  - 使えるやつから使ってみて、使ったやつ以前のやつは省いた貪欲で解いた

#### 006
C
- 解けず
  - いつものようにa+b+c=n, 2a+3b+4c=mとやってもダメ（TLEと、なぜかWAが生えてきた）
  - 解説は読めない
  - 他の回答をみるとO(1)でもいけるらしいがぜんぜん読めない
D
- 読む -> LISを引けばいけるやんけ！->ところでLISの実装方法は忘れたよ
  - LISの実装、AOJから勉強したら、AOJだと`O(N^2)`で解けないやつで、でもこの006 Dなら解けるやつで、それを知らずに`O(NlogN)`を初めて知ったので最初から勉強し直したんですよね
    - ただし理解したとは言ってない
  - ということでパクって後者のやつで提出
- ハァ（ドデカため息）
  - atcoder problems の difficulty からみるとだいぶ簡単な部類に入る（昔の問題だからなんだがな） もっと果敢にDを倒していこう

#### 007
C
- ただの超典型BFSなんだけど謎のバグで無駄に時間かかったし結局バグは回避しただけでまっっったく納得がいかない
- キレそう
- 結局はただの超典型BFS
D
- 超典型のdigit DPらしい
  - なにそれ
  - 調べた
- digit DPとかいうやつに初めてあたった。こういうことか
  - 理解するのに半日かかった
  - いうてどうせ典型しか解けないので理解できてないってワケ

#### 010
C
- はい

#### 011
C
- 0からスタートして3,ダメなら2,ダメなら1を加えてく
  - 加えるときにnを越えないという条件
  - ぜんぶダメならもうお前はダメだ
- カウントの上限と最初からn==ngの場合をちゃんと考えておく
- dp解があるらしいがまったくわからん

#### 012
C
- あんま解いても意味ないC
- 数学でもアルゴリズムでもデータ構造でもない さんすう
D
- 全点間最短経路を求めた上で、「最悪のケースの最小化」を目指す
  - この日本語がちょっとむずい
- iからi+1~Nまでの地点での最悪ケースを保存（つまり最大値）
- それをi~Nまでやってそれぞれ出し、毎回最小値を更新
- ということでワ―シャルフロイド

#### 014
C
- いもす法入門
- どっかでみたな〜〜っつって公式みたら問題例そのまんまっぽい感じのやつ
- 完全に忘れていたので一読した
- いい加減そらで書けるくらいになりたい..
  - 0WAだったけど自戒を込めて
- 3ヶ月ぶりに解いた。前回のは覚えてない
  - 典型imosが浮かんだ
  - n,a,b=1,0,0のコーナーケースでWAなるコードを書いてしまった...
- 半年ぶり？に解いた。go
  - 典型imos
  - なんかrubyよりだいぶ遅いんだけどどうしてなんだろうね
    - あーたぶん雑にやってるんで`bufio.Scanner`じゃなくて`fmt.Scan()`使ってるからだろうね あと最大値を取得するためのループをわざわざやってるからだと思われ（試してない）
#### 015
C
- nもkも小さいのでそのままDFSして見つけたら終了っていう脳筋
- DFSとxorの問題
  - xorは直近やった121Dで出てきたばかりだけどどうせ小さいのでなんも効率化せずに回した
- クソ寝ぼけてて頭が働かなかったのでこの程度の低レベルな再帰ごときに時間をかけてしまった
  - dfsの再帰のこういう形（ひとつだけの解を出すため呼出し元にreturnしたりはしない）っていうのは好きじゃない
- shit one.
D
- dp[i][wi][ki]でいけるんちゃうかとチャレンジするも7WA+ほとんどTLE
  - んー？10000*\50\*50で間に合いそうなもんだが
  - いややっぱ間に合うっぽい
    - **（ここで数時間アンド数回のアタックで振り返ろうとするも飲酒しててどういうつもりでコードを書いたのかわかんなくなりました）**
    - **(いやまあ結局まだ解けてないんですけどね)**
- 間に合うっぽいのでやった結果こうなって、
  - [これ](https://atcoder.jp/contests/abc015/submissions/10778688)
- メモ化再帰だから駄目なのか？と思って三重ループにしたけど、なぜか余計にTLEどころかWAが増えたしわけわからんくなった
  - というか実装すら分からず、参考にしようとしたやつをちょっとずつ部分部分で写経てたらいつのまにか丸々パクリになってしまったのにも関わらず、なんかしらんけどTLEになるというなんだこれ
- Pypyでも出来なかったが、dp配列の初期化を内包表記ではなく`[[0]*(w+1)]`みたいな感じにしたら再帰でいけた（なんでだろうね）
  - 「じゃあ三重ループのうちふたつを`[[[0]*(w+1)]*(k+1) for _ in range(n)]`みたいに`*`でやればもっと早いのでは？と思ってやったらMLEなった（なんでだろうね？？？？？？？）
  - Goでやろうとしたんだけどなんか駄目だね（なんでだよ）
    - なんかREなる（再帰）（マジでこれなんなんだよ）
    - [これ](https://atcoder.jp/contests/abc015/submissions/10797726)
#### 016
C
- 解説が一切わからん。は？最短経路？
- 適当に二次元リストで友達のIDを保存していくとなんかどっかで重複するっぽいんだけどわけがわからず、それもリスト取って確認したら重複してるやつ除けばいいっぽいのでそうしたんだけど原因が一切わからん
- ↑でわからんいうわりに一度rubyで解いてたらしい。今回はそれを見ずにpythonでやってみた
- はじめは2パスまでのdfsでいけるやろと思ってやったら無限にバグらせて30分くらいかけた 馬鹿だね
  - 友達の友達が実は友達、というのを考えてなかった。これはわりと早く気づいたけどそれまで書いてたコードにこのロジックを盛り込むのが厳しかった
  - 問題文の意味を読み違えていた。友達の友達に至る経路を出していたけど、本当は友達の友達の数だけが欲しかった。これは気づくの遅れた。
- で、あとで前回のAC提出コードを見返したらループでやってて超クレバーだった あたまがわるくなってるね 退化

D
- 【重要な気付き】問題の条件から、切断する線分の端点は図形の外側にあるので、**最初の交差で図形の内部に入り、次の交差で図形の外に出る**を繰り返すことになる。一度出入りすると切断される図形が1増える
- なんか2Dの物理ゲーみたいなのでよく見る感じがしたので、`「線分 交差 アルゴリズム」`とかで適当にググって出てきたやつを実装した
  - 以上です（なので結局なんもかんがえてない）

#### 019
C
- また問題文を読んでなかったやつ
  - 与えられる配列から[i]*2 = [j]になるやつを探すのかと思った
- domn

#### 023
D
- 難易度がフットーしそう
  - 「にぶたん」という問題ジャンルまで与えられたのに答えられない
  - スコアをにぶたんするところまでは思いつくが、そのあと**その得点を実現するまでに試行する回数の上限**を貪欲で求め、それを試してあってるかどうか判定、というフェーズまでたどり着くことができず。
- 結局いくつか解説をggってもわからず、写経したと思ったのに通らず、あたまがわるいからだね。しかたないね。向いてないね。
  - というかlower_boundのノリで実装したのがマズい？**最大値の最小化**とかの問題は`while(r-l>1)`で、`l=mid`と`r=mid`で更新するのが常套だっけ。。。もうあたまがわるすぎて駄目

#### 024
C
- まず`K<=100、D<=10^4`なので全探索の気持ちが芽生える
  - Dを保存してK回回すといけそう
- できるだけ大きく動いたほうがいいと気づく。なので上限（r or l)まで動く
- 最小回数ではなく最小日数であることに気づく。つまり**今日動いても明日更に動くから今日は動かなくていいや**は無意味、であることに気づく
  - Di=[1,2]でDi+1=[1,3]の場合で、右に行きたいとき、Diで動いたところでどうせ`3`に動くにはDi+1を踏まないといけないが、べつにDiを踏んだところでデメリットはない
- というのを計算。

#### 026
C
- いや再帰するだけなんだけど。rubyがクソなせいでreturnの部分のクソ簡単なバグが取れずに数時間溶かしたのでキレ気味に追加

#### 27
B
- Dificultyが800越えのABC-Bって珍しいなと思って解いた
- 最初シミュレーションのつもりでやってたけど、途中で天啓
  - 「多くても少なくても橋かけなきゃ駄目じゃん」
  - 「今みてる時点のidx * dividerがいまの累積和じゃなかったら橋かけなきゃ駄目じゃん」
- でなんとなくやってAC うれC
  - Dificulty的には易しめだけど気づきの問題として入門的で嬉しい

C
- なんやこれ 2/N+1~2/Nを取れば勝てるのはすぐわかるけどそのあとがわからん
- 答え観た
  - atcoder tagsによるとGame たぶんGameの中では最弱
  - わからんやろこれ

#### 028
C
- あさかつからきました
- やるだけ どうせ10パターンなので直書きした

#### 029
D
- 「桁dpの問題」みたいなリンクからやった
- 解法ヒントがあればまあその程度って感じ
  - 1ってのがミソで、単に数えたものの総数なので最大でも桁ぶんしか無い
  - ので、メモリに乗る程度のメモ用テーブルが組める
#### 032
C
- 文字読めないから順序うんぬんを飛ばして読んでて、「ソートして頭からやればいい」と思い込んでた
  - キレて解説みたらは〜ん？となった
- 尺取法とかいうのを解説に沿って実装したが3ケースでTLEになる クソ
  - 積をいちいち計算してたらダメらしく、計算結果をもつ変数をもたせると3WAなる クソ
- 結局わけがわからんが、r == lとなったときにr+=1して結果を1にするみたいなことをするといけるらしいがまるでわけがわかりませんね、クソ
#### 034
C
- 数時間かけたが一切理解できなかったので諦め問題
- 俺たちは何回「こんなんDPでいけるやろ典型」とか言って挑戦して玉砕してるのか？
  - ついさっきやった（2019/03/05 23:36 戒め）
- フェルマーの小定理？？？？？？？？？なにそれ
  - ggって唯一納得のいく説明[https://www.surweb.jp/sur/faq/fermat1.html](https://www.surweb.jp/sur/faq/fermat1.html)
- 逆元？？？？？？？？？？？？？？？？？？なにそれ
  - なんで逆元を求めればいいのかさっぱりわからん無理。階乗の話じゃないの？
- 繰り返し二乗法?????????????????????????????????????なにそれ
- 半年ぶり？初回提出から1年ぶりにアタック
  - 未だにフェルマーの小定理とか繰り返し二乗法とか逆元とかしらんけどとりあえず`powMod`はもってるから貼って殴った
    - 原理は全くわからん
  - ただの`powMod`典型なのでちょっとでも応用が出てきたらぜったいに詰む...

#### 035
B
- `?`をカウントして最後に動かしても同じなのでそうする
- 最小値、0未満にならないようにするのと、差によって0か1か決まるので注意

C
- fuck. いもす法とか知らない。なんか頻出いうわりに初めて知った。使い方も実装も（この問題では）簡単だったけどたぶんいつもの典型以外解けないやつだろ
- あと解説文に騙されたが冷静に考えればi番目をi+1に加算ってのは嘘でiにi-1を加算だろうが

#### 037
C
- ↑C35ひと月前にいもすとか知らないと書いてたな、まだ1次元だけだが相当出てくるぞ > 1月前の俺
- 変形いもすであぶれたぶんを引いていく感じ
- 実装はなんか泥臭いというかもっと工夫できたんじゃないかな

- 4ヶ月ぶりに解き直した
  - いもす？普通に累積和してACだが？
    - 累積和とっといて範囲外の最大から範囲外の最大を引けば範囲内の総和が求まるんじゃね的な
  - とか思って前回解いたやつみたらなるほどね いもすじゃないけどねこれ
   - kから始める、を考えず、0~nまでやるんだけどk未満は無視、は確かに。無駄だけどこっちのが考えるの楽だな

- 何ヶ月か知らんけど初めてGoで解く
  - 累積和典型から来たので最初から使用アルゴリズムがわかってた
  - 途中で最初の一回で駄目になると気づいて無理やり帳尻合わせしたやつ
  - ```go
  	for i := k - 1; i < n; i++ {
      if i == k-1 {
        ans += arr[i]
      } else {
        ans += arr[i] - arr[i-k]
      }
    }
    ```
  - ふつうにans=arr[k-1], i=kから初めりゃ問題なかろうに。。

#### 038
C
- ACしたけど解説みたらああそんなアルゴリズムあったね...ってなった
- 単調増加しなくなるまで長さをとっておいて、しなくなったときの長さをLとすれば∑(L)個出るのでそれを足していく、最後に残ったLもちゃんと処理する、っていう方針でやった
- 言うまでもなく解説の尺取法使ったほうがスマートでクレバー
  - 計算量は変わらん せいぜい∑(L)のぶんがネックになる程度

#### 040 
全体的に脳死お断りな気がする（実力）

B
- なんか旧問題だけどDifficultyが高いB
- 3回目のアタックで、1回目は二重forの全探索で通してたっぽい
  - 2回目はなんか駄目だった（コピペして投げただけで中身は確認してない）んで消した
- 単純に、yを決め打ちする。縦は`n//y`が最適になる（あまりが少ないので）


C
- 超典型DP
- よくよく考えれば`dfs(i, cost)`や`dfs(i, step)`なんかのメソッドは必要なく、単にDPの配列のみで良いことに気づく（2REして意味不明なったんで答えみたらわかった）
  - そもそも **蟻本曰く、引数にコストを含めるのは愚**なので`dfs(i, cost)`はダメ
#### 041
C
- kuso. 座圧的な発想はすぐに浮かんだ、まではいいんだけど
- その座圧の実装がどうやるか思い出せず、配列っしょwと思ってたわ
  - 辞書でした。死ぬべき
    - 解説みるとふつうにpairでもいけるので、べつに辞書にとらわれる必要はなくて、単にお前の頭がゴミだったってだけ pgr
- マジで何年やってんだ 脳味噌腐ってんじゃねぇのか
- さっきなんも見ずにpythonで実装したら一発だったんだけど、発想が座圧なのは浮かぶけど座圧の実装は忘れた。愚直にリストでやった
#### 042
C
- インクリメントするか...いや間に合わないか
  - 一文字ずつとってみるか...いや上下どちらからやっても繰り上がりがうまくできんな...
  - どうすっかな...激ムズだな...
  - 解説みる -> クソでした死にます
- さっき4ヶ月ぶりにやり直した。問題読んで場合分けめんどくさいなーとか思いつつ10分くらいtwitterに逃げてて、戻ってきてから「N<=100000だしインクリメントでいいんじゃね」となってやったら通りました
D
- dpマップを作ったところでnCrの計算ができず、ひとつずつ見ていく想定でやってたので間に合わないことに気づく。
  - -> 死亡
- 死亡したので解説を読む。ちっともわからん。
  - 1ググりして出てきた[これ](http://tatanaideyo.hatenablog.com/entry/2016/07/24/031338)を読んで（これは公式の解説とは別の解法だが）わかった気になったつもりになり、実装はせず
- ムズい なんだよフェルマーの少定理て nCrて これは数学です
#### 043
C
- 「minとmaxのmid（+1 if odd）したやつをターゲットにすればいいかな...」
  - なぜか負数があるがこの考えだと無意味なんだよな引掛けか？？
  - もちろんなんの根拠もないし考察なんてしてない、サンプルが通るだけ
- 解説みる -> マジでクソ。
- > この時-100から100 までの整数しか考える必要はない。(-100未満や100より大きくしても、各(ai-X)^2はX=-100や100の時と比べ大きくなるだけなので、無駄。)
- これの意味がわからんけど、要は
  - ai=100のときは100にしたら(x-y)^2=0になる、100より上だと増えていく
  - ai=-100のときは-100にしたら同じく0になる
  - っていうことだろう
- いずれにしろWAしたしクソ
- 4ヶ月ぶりに解いた。ひと目で(max-min)/2を目指せばいいやんと思いこんで以前書いたコードを見て驚愕した。全探索。。。制約をちゃんと読もう....
  - 精進問題....
- 何ヶ月ぶりかはしらんけどふつうに全探索で終了。5分問題では？

D
- 初のなんも見ずに解いたD
  - 🎉
  - 考察もだいたいあってた
- 初めてだと思ったらすでに回答済みだったのね（なぜかデータベースには残ってない）
  - 最初は尺取かと思ったがよく考えると実装できないことに気づく
  - その後、「過半数」なので10文字だと同じ文字は6つないと駄目で、35文字だと18つ必要になる、と気づく
  - つまり、連続する3文字を抜き出すとどこかで必ず「同じ文字が2つ以上」という場所がある
  - あったらそこを出力すりゃいいだけなのでそうする
  

#### 044
C
- 「途中でぶった切る再帰で十分だろ」->「げぇっ最後のサンプル確かにこういう場合があるのか...確かに..」
- で解説みた
- まあふつうにdpだったんですが変数のもたせ方にまったく自信がなくてそのへんは解説見た
  - 三次元dpで50\*50\*2500ってのは直感なんだけど、そんなでかい数値ありえねぇだろってのもまた直感
  - ふつうに計算すれば間に合う感じでした
- メモ化再帰を組めるのは楽しい
- だがfuck 何時間かけてかいたんだこの程度に
- 何ヶ月ぶりかのチャレンジ
- 最初二次元DPでいけんじゃねとか思ってた
  - で、実装途中に無理ぽいことに気づき、三次元だとメモリ死にそうと思って↑のメモちょっと見ちゃったんですよねはい
  - で、意気揚々とやったらTLEなったんですよねウケる
#### 045
C
- 愚直解しか思いつかなかったのでやったが実装がハゲそう
  - 途中で耐えきれなくなって解説をみたら愚直解だったのでなんとか書ききった
  - つらい
- 合計値を出すメソッドよく書けたなこれ...
- いくつ入れるか+どこに入れるか、でnからc個とる組み合わせのやつをc++していったのだが、解答のやたらと短いやつをみると「+をいれるかいれずにつなげるか」のdfsっぽいのがあったのでぎゃふん
- pythonで解き直し。以前の回答は見てない
  - eval is evil
  - 愚直回しか思いつかない。再帰で入れるかどうか判断していく
  - Cのわりに簡単すぎる。200くらいでいいんじゃないか。再帰入門的な
#### 046
C
- shit one.
- 地道にインクリメントして当然のようにTLE
  - じゃあにぶたんで求めるか〜ってところで鬱になったので1秒で諦めたのだが、ggるとにぶたんでやってる人もいた（通るらしい）
- 解説をみたが1bitも理解できないのだが...?
  - 比になるのはいいとしてなんで *このようなxは~で計算できます*になるのだ
  - なんで計算できるかをしりたいのだが?
- 解説例の解説 わかった気になる [https://ameblo.jp/weibeicun/entry-12438868527.html](https://ameblo.jp/weibeicun/entry-12438868527.html)
D
- DPかなと思って実装したがN=20程度でも帰ってこず、死
- 答えみた
  - マジかよ考察力....
  - 相手も同じルールってのが抜けてたわ
  - これは太刀打ちできん考察問題のレベルを感じる
- 5ヶ月ぶり？に解いた？ D埋めしたかったのでDifficulty弱めのやつを選んだ
  - えっ ふつうにDPじゃないのこれ 考察？そんなことある？別問題？
  - ふつうにDPっつーかメモ化したんだけどPythonで解いたらおなじみの`recursionlimit`と（テスト用に書いてた）それまでどんな手を出したか知る用の文字列保存と加算のとこでTLEになってた。消したらいけた
  - 考察....?????
  - ごくふつうの一次元DPでいけるよ....?????

#### 047
C
- 頭からみていってシミュレーション的に変えていくのを思いついて、よさそうだというところで、実装の前に**以前かいたやつを見てしまい**、それは解説を読んだやつっぽかったんだけど,自分が思いついたやつよりも更に一歩考察を進めたものだった。。。。
  - 死
#### 048
C
- 前やったのを覚えていちゃった
- 前やったのを忘れてた
  - こういうのは頭からみたときに自分と自分よりひとつ下のやつだけを見るので、減らす数を最小にするのならばひとつ前はどうせ次のときは使われないので、自分を優先にして引いたほ
#### 049
C
- 「ははーんこれは幅優先だな」 -> あぼーｎ
- 解説みる -> は？？？？？？？？？？？？？？（激怒）
- これはひどい
- 4ヶ月ぶりに解き直した
 - 解法覚えてた
 - なぜか意味不明なことに1WAして完全に意味不明なったけどな
#### 050
C
- はい
  - 履歴消えた？？？？？
- 最初から考察は出来ていたっぽいのだが現行atcoderのrubyのバージョンが時代錯誤すぎて1WA,仕方なく直したやつでTLEを喰らった
- ので、別の視点から書いた
- nから配列は一意に同定できるのでそれを出して比較
- 見てりゃわかるし難易度はミドリムシ程度
- fuck one damn it shit kill
- 数カ月ぶり 今回はGoで解いた
- 見た瞬間に解答が浮かぶ（nの偶奇で配列が求まる）が、Goによる実装がしんどい
  - 正しい配列を作って比較
  - Goのスライスの比較はできないのでいちいち要素ごとを比較した...
- 最悪なのが問題文を読んでなかったせいでMODを取り忘れ、かなりの時間を費やしてWAの山を築いてしまった....

#### 051
C
- 最短距離は(tx-sx)回x方向と(ty-sy)回y方向に動くやつで、1往復すると周囲2マス使えなくなる
- そこを避けて最短距離の外側をとおる
  - 位置関係が判明しているのでそのぶんR, L, U, Dを繰り返せばいい

#### 052
C
- さんすう 数学
- このくらいすぐ解けバカ 実装遅い
- Nが小さいのでせいぜい全探索の気持ち
- Nの約数の個数はググれ 素因数分解してそれぞれの出現数+1をかけ合わせる数
- NとN-1の約数はそれぞれ独立してる
- 適当に1からNまでの素因数をメモっといて、最後にそれぞれの数+1して掛け合わせて計算すればいい
- 素数列挙にはエラトステネスを使った

D
- きりみんちゃんの放送で500の中では最弱ときいて
 - マジで最弱だった dpですらない
- 毎回次のステップと今のステップの差だけを考えて更新していくだけ 終了

#### 053
C
- damnit. 計算はだいぶ悩んで浮かんだ。ただし実装がクソ
- 死にたい
#### 054
C
- 超典型グラフDFSの超簡易なやつ
  - 特筆することはないが一番最初の練習にいいんじゃないの
- Goで解き直した
  - やっぱ超典型DFS

#### 055
C
- 考察あってたんだけどなぜか実装でそれに従わないゴミ回答をしてしまい1WA...
- 問題自体はAレベルのさんすうだっただけにクソ
- 4ヶ月ぶりにぶりに解き直し
  - 方針は1秒だったけどなんかしらんけど場合分けをバグらせてハマった......退化....
#### 056
C
- 何回か挟んで考えた 
  - そのうち何度かはクソ
- 提出したやつはまとも
  - ただ、`10**9`ということで、最初にぜんぶとってからの累積和、というのは最初に取る段階でTEFなるのでダメ
- 以下かんがえたやつ
- A[n]からA[n-1]までの数は問題の性質からそれまでのA[i]を調べて任意の数を取って並び替えればどれかは達成できるやつになってる
  - なので適当に累積和っぽいこと(TLEなるのでメモリにはおけない)をやっていって更新してく感じ
  - わりと思いつかなかった 死
#### 057
C
- 一年前にgoで解いてたらしい
- 今回pyでやったんだけど、解けたんだけどgoの答えみたらクレバーだったしなかなかに時間かかったので負けです
 - goでやったやつ range sqrt(n)してiで割り切れる最もデカいのを保存しといて最後に商との桁を比較
 - pyでやったやつ 素数以外として、10^10なら最大で5桁までをみればいいのでふつうに全探索したあと↑
- 微妙に思考過程が違ってて面白い
#### 058
C
- 前回は4ヶ月ほど前にrubyで出したらしい。今回pythonで解いてから.rbのほうをみた。基本的な方針は同じで、実装が少しクレバーだった
  - 最初のやつを基準にしてそこに含まれているものだけを考える、とか
  - 今回はわざわざN個文のアルファペット辞書を用意して、N回回してからもう一度最小値を取るために回して、というのをしたが、最小値も都度更新できるので。
- 現時点でatcoderのpythonのバージョンが低いため辞書が順番を保持しておらず1WA。
- 三ヶ月ぶりにやったらなんかわかんなくて↑の「最初のやつを基準にして」最小値を更新、をカンニングしてしまった
  - 衰退
  - 死にたい

#### 059
C
- 一年以上、10回以上アタックして駄目だったやつ
  - 毎回解説を読んでなるほどとなるも実装できなかったやつ
  - 「今の累積和で判断」かつ「インデックスの偶奇で正負を両方試す」かつ「累積和を更新および代入で変えてしまえば専用の配列をもたなくていい」などなどがよくわからんくなってしまうのが原因？
  - ゲキムズC Cの累積和問題の中では一番むずかしいのでは

#### 060
B
- Nが少ないので試せそう
- あまりはループするので0か二回同じのが出たら終了。終了判定だけでいい

#### 062
C
- n回くらいトライしててぜんぶ同じ戦法（3で割った商を越える最小のw\*iかh\*jを抜いたものを2で割った商を越える最小のw\*iかh\*jを導出）でやったんだけどいずれもクソ
  - 考えすらあってるのかわからんけど
- 答えみたらパターンで全探索だった
  - は？パターン？
  - abcで分けるとするとこうなるよねっていう図式 納得いかん
  - 解説読んだらとりあえず解けたけどこんなもん誰も浮かばんだろ
  - しかも*4パターンのうち2パターンはもう一方のh, wを入れ替えたもの*とか*できるだけ差が小さくなるってことで二分でいい*とか細かい気付きも要求される
  - 非常にダメ
  - 自尊心死んだ
  - こんなもんに数時間かけたのマジで鬱なる
  - キレたし泣いた
  - デカい声では？？？？？？？？？っつってたら近所のおじさんに怒られたのでマジで死にたい

#### 063
C
- 点数が大きいほうが嬉しいので、10の倍数にならないように低い点数を引く

#### 064
C
- いやこんなんふつう最大8色って思わない？問題文じゃなくて例題にしれっと「紫」「黒」とか書くの悪問でしょ
- あとなんかしらんけど`array[8]`にしてまだとってなかったら=1にして最後にsumする、ってやつだとなぜか2ケースでWAで、`bool[8, false]`してあったらtrueにして最後にtrueを数えるっていう、まったく同じロジックのやつだと通る。これはpythonとrubyで試したけど完全に謎。バグでは

#### 065 
B
- 終わるまで試す。次の値をインデックスにして参照すると、その次の値が取れる
- 一度でも通ったところにもう一度きたらNG。2だったらOK
- 最初リストで持ってて、毎回`if target in lis:`してたのでTLE
- ちゃんと10^5要素のBooleanのリストで管理してAC

D
- むずくて解説読んでギリギリわかりそうだったので解いたという感じの肌感
- 問題文読む感じだと「最小全域木 -Minimum Spanning Tree- MSTだッ」となるが、それ以上にはいけなかった
  ― 具体的には、**こういう二次元座標系の問題はどちらかの軸でソートするとみえてくるものがある**という経験則から考えると、（軸基準で）明らかにソートした順番でやったほうが得だというのがわかる
  - が、二軸あるので、これをどうすりゃいいのかわからんかった
- 解説を読んで **「xでソートした結果できたエッジとyでソートした結果できたエッジの2つある」と考える**のがほぇぇ〜〜〜んとなった
- まあこれだけではべつに本質が見えたわけじゃなくて、グラフとこの解法を具体的な図で頭に浮かべることができないので、少なくともまだ自分にとっては「感じろ」ということなのだろう
- そこまで落とし込むと高々2(N-1)のエッジになるので最小全域木アルゴリズムで殴ればいい
  - まあぼくはなにひとつ憶えてなかったんでAOJのADSLから再入門したんですがね。プリムとクラスカルの名前も実装も忘れてた
- かなり無茶な実装をしてGoで1400msだった。Pythonだと通らなさそう

#### 066
C
- 4ヶ月前もやってて通してたっぽい
 - Cの中でも最弱
- 似たような発想だが、今回は後ろから作っていっているのに対し、前回のは（なんかたぶん前からやるような）別のアプローチでやっている模様
  - なお前回やっていた記憶はまったくない。記憶に残らない程度の簡単な問題ということだろう

#### 67
C
- 累積和の、なんか `y-x`するやつの典型（名前失念。なんとかの定理？）
- まあそれだけなんだけど、知ってないと解けない典型
- ちなみに制約`1枚以上のカードを取る`を読み飛ばしていたよ

D
- 解説見た
- 木なので閉路はない->任意のノード同士をつなぐ経路が唯一存在する->1とNの経路を先に制してから自分の色で塗れるノードを塗る
- という考察を進めると、ノードiにおいて1からの最短距離とNからの最短距離を比較することで、そのノードがどちらの色に属する（つまり最も早くたどり着けるのはどちらか）かが判定できるので、その差からどちらか勝つか分かる
- というのを、2回BFS（1からとNから）して各ノードへの最短距離を記録し、それを比較してGO


#### 068
C
- 何回かにわけてアタック
  - いずれもすぐ諦めてたけど
- さっきの試行で、a==1以外とb==N以外はみなくていいって気づいた
- ので、適当に実装
  - いうて1時間くらい？かけたんちゃう
  - 映画みたり酒飲みながらだけど
- 意外とうまくいってうれpのだが数回アタックしたのでダメ
- 三ヶ月ぶりに解いたらしい
  -うっっすらと記憶に無い
  - 三点で考える場合は中間地点の気持ちになる。今回は始点と終点が決まっているのでめっちゃ楽
- 9ヶ月ぶりに解いたらしい
  - 最初2回のDFSでやってたら2TLEが取れなかったので死んだ
  - 諦めて、`1とNを含む島を探す`にシフトしたら通った
  - でも↑の9ヶ月前の解法のが天才だわ 退化しとる

#### 069
C
- 4の倍数と奇数だけに注目すればええやんけ〜
  - 無事死亡
- キレそうになりながらコーナーケースとダメケースを考察したら思いつくまで少し時間かかった
  - それはいいのだが実装までも無駄に時間を喰ったのがマジで気に入らない
- fuck
- 何ヶ月かぶりにやった（なんでgit使ってるのに履歴無視するんだろうね）
  - きりみんちゃんの配信からきました
- ↑で怒ってるんだけど、愚直にサンプルを手元でやってコーナーケース潰す（`1 4 1`はいいけど`1 4 1 2`は駄目だよね的なやつ）
D
- 問題読んでないけど一行にして折り返せばいいよね
#### 070
B
- ついにBごとき問題でもWAをやらかした
  - マジで死ぬべきだと思う
  - こんなんを間違うやつが生きてても世界になんの役にも立たない
- は？？？？？？？？？？？？？？？？？？？？？
C
- 読んだらlcmを求めるってことくらいは理解できる
- なので全体のlcmを求める
  - 公式知らんかったのでggった
- アルゴリズムのコアの実装は合ってたけど渡す値と答えをミスってて1WA
- まあアルゴわかってただけでいいっしょ

D
- dfsかと思いきやweighted disjoint setかと思いきやdfsらしい（解答観たらそんな感じ
  - 解答みたのにそれで実装したのになんかしらんけどTLE増えたしREも出てる 意味不明
  - PypyにしたらREだけになった
  - recursionlimitを添えてTLE4つ
  - (pypyで）DFSの探索済みの箇所をリストじゃなくて辞書で持って残り1TLE
  - で、同じコードをPythonであげたら通った。。。PypyはDFSのような探索系は苦手？

#### 072
C
- scum.
- 最初最頻値+-1を足してて2WA.
  - マジでこれしかないだろと思ってた
- 諦めて解説読むとあばばばばばばばば
  - 一瞬で最頻値の反例が浮かんであばばばばばっばばばばばばばばｂ
  - こういう低いレベルの"気づき"がまったく出来ない、死にたい
- 4ヶ月ぶりに解いた
 - 最初N個の+-1だけみててWA(3 4 のとき 2 になるのを忘れていた)
 - ので、10^5ぶんを全探索した

D
- 単純な貪欲で頭からiとi+1をswapすればいいと思ってn-1回回したわけですがn回目でまさかのi==が発生するようで、これがわけわがわからん
  - は？？？？？？？？？？？？？？？？？？？？？？？
  - トイレいったら思いついた `4 3 2 1 5`の場合があるのでn番目まで見ないといけない。。。。
- 半年ぶりにやった こんな問題あることすら忘れてた
- 5WAかましたので退化してる 死んだほうがいいね
  - サンプルの単純な演繹で「i==A[i]の数」-「i==Aiかつi+1==A[i+1]」を無考えで提出したのだが駄目（なんで駄目なんだろうね）
  - 茶diffすら解けない マジで存在自体地球の資源の無駄 さっさとやめちまえ はい

#### 073
C
- 辞書して偶数なら0、奇数なら1
- 1つずつみていくので偶数になった瞬間、すなわち「すでに存在している」場合は2になるのが当然なのでその場で消す
- したら結局は辞書のサイズになる
- はい
D
- 一見ワ―シャルフロイド典型じゃんと思いきや経路Rは任意の順番だった
  - ので、next_permなりなんなりですべての組み合わせを試しましょうね

#### 075
B
- よくある2次元探索
- Bっぽくない気がするけどまあ所詮B、と思ってたらコーナーケースとその直し間違いで3WAくらいくらった
C
- グラフ問題
- 毎回特定の橋がないグラフを作ってDFSで全域木かどうか求める
  - です
- 3ヶ月ぶりに解いた
  - 前回解けてたみたいだけど「辺を取り除く」が生えなくて解説みたよね 退化
  - 隣接行列で辺が通ってるか管理する方法
  - 明らかに前回のやつの解法がスマートに感じる...
- 半年ぶりにアタック、どうやらUnionFindでも解けるらしいのでやってみる
  - 最初組んでたやつ、使わない辺を固定してUnionFindしたあとのグラフにおいて、確認のために出力したものが「`par`の要素が3つ以上なら2つ以上の木ができてるってことだしアウトっしょw」と思ってたらこれがまったく入力と反する感じになり、は？？？となり、わざわざAOJの典型UnionFindで試してみたりなんやかんやしたが一向にわからず、そこから進めず
  - ↑の出力がなぜ直感と反するものになっているのかは不明だが、ググって発見したACしてるソースを読むと「そんなところを気にせず、**省いた辺の端辺どうしで`same`すりゃいいじゃん**」ということで、無事死亡
    - こちらです [ABC075-Bridge | n度あることはn+1度ある](https://everydaytekitou.hatenablog.com/entry/2018/09/27/232509)

#### 076
B
- バチャコン[「緑くらいの難易度」](https://kenkoooo.com/atcoder/#/contest/show/1209acf0-66e0-4eec-9f2e-cccbdc636578)からきました
  - 過去に何度か通してるっぽいが問題は憶えてない
    - 過去、つーか直近だとひと月前らしいんだけどマジでお前憶えてないの？
  - 再帰入門みたいな感じ
C
- 解いたの2回目だけど前回のは記録なかったみたいだ（提出はしてAC取っていた）
- Nが小さいので全探索できる。辞書順で小さい順なので後ろからみていく
  - ```python
    for i in range(len(s) - len(t), -1, -1):
    ```
- `?`か同じ文字がそろったまま`len(t)`までいければそこに代入でき、残った`?`はすべて`a`で埋める

- きりみんちゃんねるからきました（2020/02/02 22:43）
- 4日前に解いたばかりだった。。。
  - A~CをGoで解いた。
  - Goで文字列をインデックスで扱うようなの、頭が混乱する。しかもこれは後ろからみていくやつだし
  - 同定した箇所の左側（~i）と右側（i+len(t)~）の`?`を`a`で埋める、というのを無理やりやった感があったんだけどちゃんと一発で通った。アルコール入った脳味噌かつGolangでこれは上出来


#### 077
C
- fxxk 2TLE 2RE
- 馬鹿だから「せやにぶたんや!」まで思いついたくせに、「nibutan(B, ai)してB[idx:]ぶんだけnibutan(C, bi)」するっていう無意味なことやってた
- 3数の大小関係の場合は真ん中の数字を基準にするとうまくいく関係性がある
- 数ヶ月ぶりにアタック
  - といっても問題ジャンルから飛んだのでにぶたんということがわかっていた時点で練習にはなってない気がする...
  - `lower_bound`と`upper_bound`を貼って掛け合わせて足していけば終了
#### 078
C
- Cの中では最弱
- テストケースの式の意味とかなんでそうなるのかは知らんけど、要はmの数だけ通るか通らないかの状態と組み合わせがあるわけで、最悪2^m回目で通るわけだ
  - というのを式に落として終了
#### 079
C
- Cの中では最弱
 - せいぜい2^3通りなので全部試せばいいだけ
 - eval is evil
- 2ヶ月ぶりに解いた bit全探索の練習にきました
  - はじめてGoでやった
  - つーかbit全探索が正当な気がする

D
- これを初見で「ワ―シャルフロイドだ！」と気づけれたら勝ち、そうじゃなかったらお前の負け
- 与えられる10x10のテーブルはワ―シャルフロイドでいうところの初期状態フェーズを済ませたようなもので、そのまんまこれをもとにワ―シャルフロイド使って更新できるので更新してしまえばあとは参照するだけ
  - とか物知り顔で書いているものの、ワーシャルフロイド使うと知った上でトライしているので駄目
    - これ解く前は10回以上アタックして駄目だった気がする

#### 080
D
- 二次元というか、各行がチャンネルを表し、横に時間ぶん伸びたいもすの集合体と考えた
- いい感じだと思うんだけどなぜか2WAがとれず...
- W*Hのwallには特に意味はなく、それぞれの数値の登場回数だけ問題になるっていう引っ掛け
- 0, 2~9から1までの最短コストを貪欲に求める
- というのをPython3だとTLEでPypyだと通る
- ...が、解答をみると実はワーシャルフロイドを使うらしい....... は？
- ということでワーシャルフロイドってなんだっけってところからググって実装
- k, i, j = 経由点, 始点, 終点としてこの順で3重ループして隣接行列を更新する
- `table[i][j] = min(table[i][j], table[i][k] + table[k][j])`
- めっちゃ簡単やんけ しかもめっちゃ早くてワロタ

#### 081
C
- 方針が立ってからの分岐が勝負
- 加工する必要があるときだけ**適度に**加工する
  - 条件を満たせばギリギリでいい
- 実装とコーナーケース潰しが下手糞すぎて10WA以上喰らった

#### 082
C
- Cの中では最弱
  - と思いきや誤読して3WA...(増やせるかと思ってた)
  - ふつうに数値と登場回数をハッシュなりでもって、多かったら差を、少かったら全部を取り除くカウント

#### 083
C
- 各要素に興味がないので、できるだけ長くするには初項が小さいと嬉しい（A1=x)。そして、できるだけ長くするには, Ai+1もできるだけ小さいと嬉しい (A2はA1の倍数なのでA2=A1+A1)。これを続ける
- かなり簡単な部類に入るC
  - 解説の数式はまったく読めない

#### 084
C
- shitone. 非常にダメ。死にたい。4hと結局解答。マジでダメ。脳が腐ってるうえに文盲みがある。
- 4ヶ月ぶりに挑んで解けたけど非常に頭が悪い
  - シミュレーションでいけると思ってやる
  - c + f * nを満たすnのうちcurrenttimeを超える最小のnを求めるのににぶたんを実装したのはどうやら悪手らしくて、条件から求まるらしいんだけど解説読んでもさっぱりわからん
D
- 10^5だし愚直にやってもいけんじゃねと思ってた時代もありました
  - 間に合わなくて1WA食らった
  - 真面目にやった。累積和+包除原理
#### 085
C
- オーダー見積もり && 整数 の典型
- 以前はrubyで出来てたっぽい -> 10ヶ月ぶりにチャレンジや
- -> ち〜ん
- **上限を2000に**,をしてなかった....2WA..
  - 「これやったことある知ってる〜こうやるんだろ〜」でゴミになった感じが強い
  - 反省しろ
D
- 問題文よむぼく -> あー？？？？？
  - 3分くらいで諦める
- 解説文よむぼく -> は？？？うせやろ・・！！！！！！！！！！！！！
  - Cにしろや
- 4ヶ月ぶりに解いた模様 うっすらと解法を覚えていた感じがする
  - ai<=biなので基本的にbiが強い。最強のaiより弱いbiは使う必要がない
  - 順番は関係ないので選びぬかれたbiを強いほうか使っていって、倒せなかったら最強のaiをHがなくなるまで使う

#### 087
C
- 累積和
 - じゃなくてもNがちいさいので全探索でもいい なんでもいい

#### 088
D
- 懐かしのほぼ典型迷路幅探索
  - 最短経路以外ぜんぶ壁で埋めればいい
  - ゴールできない場合を加味忘れて1WA

#### 089
C
- 考察10秒 -> 組み合わせ出せればいいんやろ -> 実装半日
  - 結局なぜかTLE出てダメで、解説みたらふつうに方針あってたのでキレた
- クソ
#### 090
C
- あれ?過去にほぼ同じの類題やったような
- そのマスを訪れた回数ぶん裏表裏を繰り返すので奇数回訪れたら裏
- n>=3 m>=3のとき奇数回訪れるのは外周以外の、周囲すべてをマスで囲まれた部分のみ
- 余裕

- きりみんちゃんから来ました
  - PHPで解いた
  - サンプル3を手元で適当に試したら答えになったので演繹した
    - `abs(a*b-(a*2+b*2)+4)`

#### 093
C
- 小さい方2つと最大値の差の偶奇で分岐
  - なぜか過去に3WAしてるらしい コード読んだけど読めない

#### 094
C
- N小さいし都度ソートしてもええやる
  - ダメでした
- 解説がなにをいってんのかわからんが、どうせ1ずらしたところで中央値なんて真ん中か真ん中の次（前）の二択なのでそれをとっておいて配列から順番に取り出したやつと比較する感じらしい
- なんで比較してうまくいくかってのはなんかよくわかってないけどノリで書いた
- クソ

D
- アイデアは合ってた
  - 「nCr的に、nは最大でrはnの半分に近いほうがいい」
- ただし実装が大混乱でカオスになってしまったしn時間かかった
  - n時間かけて解答見ずに解けたのはいいが...
- 求めるのはにぶたんかlower_boundなりでみてその後ろと比較する感じ
- アホだったのは、ムダにupper_boundとncrを実装したところと、半分にしたいっつーのに`n//2`とかやってて無限にバグらせていたところ

#### 096
D
- 10ヶ月くらい前にアタックして見事に撃沈してたっぽい（なんも憶えてない）
- 今回しっかりと考えたけどなんもわからんくなって死亡
- して、解説youtube配信見る
  - して、なんやこのギリギリ気づかん天才回答...!!!!!ってなった
  - いやなんつぅかなんでこれ気づかなかったんだよってなったけどマジで脱帽

#### 097
C
- 解説見る -> わからん
- ggって解説記事見る -> なるほど....
- ロジックは単純なんだけど全探索をfor二重でやるのすら思いつかない程度の`permutation`クズ
- 腑に落ちないってことはなく、まあそうだよね感があってあんまりキレはない🤬 

- [「緑くらいの難易度」](https://kenkoooo.com/atcoder/#/contest/show/1209acf0-66e0-4eec-9f2e-cccbdc636578)からきました
  - ARC097Cと同じなのを知らずにそっちにも書いてた
  - 何ヶ月ぶりかはしらんけどバチャコンでは7秒前というギリギリに通す
    - それまでgoでやってたけどPython3に切り替えた
  - Kが小さいので、それぞれの文字+4文字先までみる全探索でも間に合う
  - 前回は解けなかったみたいなので今回解けて嬉しかったですまる

D
- 2時間考えるも何もできず->解説みてunionfindを使うと知る->unionfindをどうやって与えられた配列に適用するのかわからず2時間経過
- 結局ググって回答例見てそれをパクった感じになった
  - なんやこれ 簡単だけど難しくない？？？？？
  - というか未だになんでこれが答えになるのかよくわかってない
  - ansの導出で初めて与えられた配列とsameしているのだがなんだこれ
- 数ヶ月ぶりに復習
  - いつものようにこんな問題あったことすら憶えてない もちろん解法もわからない
  - unionfindを使うのはわかったがなぜかサイズをとってしまいバグらせて終了、前回の提出でACしていたことを知り退化を感じる 向いてないね やめたほうがいいね

#### 098
C
- ヒント見てしまった
#### 099
C
- 「N以下の6^pと9^pなんてたかがしれてるんだしそれでgreedyすりゃいいだけじゃね?」->「私は考察のない貪欲をしました」
  - 実際はgreedyだと都合が悪いケースがある。14とか110とか
- dfsを試みるも当然のように時間がダメ
- メモ化再帰しようとするも、1と6と9で[N][~10][~10]では？と無能を呈してしまい無理
- 解説をみるも残念ながら理解できるレベルにあらず、これはどこの言語
- ggったらこれは難問らしく、取り上げたqiita記事まであった
- それを見てメモ化した。dpわからん

#### 100
B
- 「100でちょうど1, 2回割り切れる」の日本語が怪しい
- 問題文が読めないけどサンプルからエスパー
  ただし世界一競プロが下手なので2WAした やめたほうがいいね

C
- 考察してないんだけど眺めてたら偶数のこころが生えた

D
- 最初の10分「3つの要素だけど基準は1つだから単純に総和でまとめればいいのでは？」 -> "各要素の合計の絶対値の総和"を読み飛ばしていて死亡
- 次の1時間「無限にわからん」->解説を見て、各基準をソートして試す
- 次の50分「できたぞ！...ん？これ6通りじゃないの？サンプルも通るぞ？」->5WA
- は？？？？？？？？？？？？？？？？？？？？？？？？？
- ソートの方向*要素数で得られるインデックスの集合がほしいわけなので6通りだろ？？？8通りだと各要素を2方向にソートしたらそれぞれインデックスが一意に決まらないじゃん何いってんの？？？？？？？
- こたえみて更に1時間「pythonで複数キーの複数リバース・アンリバースの設定ができない」

#### 101
- 1で埋めればいいことは思いつく
- 最初「1の両端からk-1ぶん伸ばせばええやんけ」ロジックでやったらWA
  - そりゃそうだ、`2 1 3`で`k=3`のときこれだと2だが、真ん中からやれば1でできる
- 考え方を変えて、1のインデックスとは無関係に頭から出発し初手はk、残りはk-1ずつ伸ばしていけばすべて埋めれると気づく
  - Nが小さいので可能
- 通ってから解説をみたがさっぱりわからん なにこれ

#### 102
C
- 2ヶ月おきくらいにやってるけど未だAC取れず
  - あたまわるいの？
- 過去に数回、延べ十時間以上使ってる気がするけど解けない（まだ解けてない）


#### 103
C
- 個人的に最速で解けたC
  - うれC
- 余りは割る数以上にはならないので-1したものの総和
- 雑すぎる考察だけどまあそんなもんだ
- 三ヶ月ぶりに解いた
  - 解けたんだけど愚直にlcmを使ってて、MLEなるかと思ったら通ったんだけど、↑の三ヶ月前の実装を見て驚愕した
  - よく当時こんなん生えたな わからんぞ
#### 106
C
- ろくな考察もせずに適当に書いて1waした挙げ句解説をみたのに更に1waを上乗せしたので吊るべき
  - わざわざ正答数が多い簡単な問題を選んだのになんだこの体たらくは お前は生きてる価値があるのか
  - 死
- shitshitshitshitshitshitsthimatherrrrrrrrrfuuuuuuuckkkkkkkkerrreeeeeeeeeeee
- 3ヶ月前にやったやつのやり直し Difficultyの低いやつ選んだのに
- 見たこと有るって言ってたのに無駄に時間かかった 混乱する
  - しかも無駄に2WA 死
D
- 何度目のアタックだよ そのたびに解説みてる気がする
- 「累積和了解！」でやると死亡する
  - ”東西に走る”がミスリードっぽさある これ1次元配列ぽさ出ちゃう
  - 同じ都市を出発地・到着地にすることは1次元座標では表現できない？
- 横軸を出発都市、縦軸を到着都市とする二次元座標で考えた時に、「座標が含まれるかどうか」を求める
  - 天才の発想 無理
- とするとクエリ(x,y)は二次元座標上の(0,0)(x,0)(x,y)(0,y)に囲まれた領域にう組まれる座標点の数を答えるものになる。二次元累積和や!（実装したことはない）
- なんかインデックスと累積和更新のところでバグらせを無限に発生させてしまい、結局写経となんもかわらん
- 実装自体は簡単なんだけど、問題文から二次元累積和にするっていうのはどうやっても思いつかんだろこれ
  - 解説みても「なるほど（は？？？なんでそれで二次元累積和が生えるの？？？？）」みたいな感じ

#### 107
C
- なんかAtcoder Problemで緑になってたからやったのかと思ってたけど提出結果になかったんで解いた
  - 手元のgitによれば何度か挑戦しててDPとかにぶたんとか使ってたっぽいが読んでない
- 単純に`[i:i+k]`までみて、両端で符号が異なれば両方の折返しを試してmin取る方法でやった AC

#### 108
C
- 何回挑戦したかわからん
- 奇数は簡単、からの偶数のときのパターンでいつも詰まる
- n, k = 1000, 4とかにしたとき、[2, 6, 14]とかはいけるんだけど、これが`kで割ってk/2余る数`だと見抜ければ勝ちだった
- は？ふざけんな 何が勝ちだよ
- これDifficulty的にもっと上じゃないの???????????????????????????????????????????????????????????


#### 109
C
- gcd使う方針はあってたんだけどなぜか使い所がおかしくて
- xiとxi+1の差でgcdを使い
- 1からその差（最大公約数）までの約数のうちで
- Xから最も近いところ（にぶたんで求めた）にいける最も大きい数を求める
- という迂遠な方法でやった gcdの更新をミスって3WA
- すべての提出で一番最初のREが取れない、これはバグでは
- マジで鬱になった
#### 111
C
- 舐めてかかったらどんどん深みにハマった
- のべ半日以上くらいダラダラとやってた気がする
- 「手続きはすぐ思いつくけど実装がまったくできない」タイプ
- fuck
- なんでこうスマートに解けないのか
  - 先天的に脳細胞が欠乏しているとしか思えない、鬱になる
- しかも解説よんでやってもWAなる
  - マジで鬱が悪化する
- 何ヶ月かぶりにアタック
  - 前回提出が1年前だった
- なんとなく方針は見えたものの実装がまったくはかどらず1時間くらいかかった気がする
  - 偶奇で登場回数をカウントして1番目が引き分けなら2番目で戦う
  - 最初GoでやっててソートとかやりにくすぎてPythonに切り替えたものの範囲外参照に怯えながら出した
- しかも結局最後は勘と提出デバッグでやった 3WA
  - なんやねんこれ 脳みそが働かん

#### 110
C
- 互いに辞書で管理すりゃいいんじゃねという方針だが解けない
  - 実装がわからん
  - 世界一プログラミングが下手 死にたい 鬱になった なんでこんなもんに数時間かけてんだ
- 全探索か？と勘ぐるもこれも数時間やって実装できず
- 諦めて答えみると理解できない
  - これほんとにDificultyこんなもんか？？？？？？？？？？
- と思ってググったらやっぱ相当難しいみたいだぞ
  - と思ったら考え方によっては簡単な解法もあるみたいだぞ。。。
- ↑から一ヶ月、ggったやつをなんとなく写経
  - 未だに直観的じゃない解で不満なんだけど

#### 113
C
- 見た瞬間座圧的なインデックス入れ替えテクでいけるとわかるんだけど、
  - 「座圧ねーはいはい どうすんだっけ」っていう程度の雑魚認識なので調べてへーってなりながら実装したので死にたくなる時間がかかった
  - 自戒
- 0WA
  - 提出してから解説を見に行ったが見ても微塵もわからないタイプの解説なのでふつうにググったほうがいいかもしれない
    - 方針は合ってたのでべつにググって別解とか探してないけどな
- chokudaiがtwitterで今日の一問みたいな感じで挙げてたのでやった。問題自体忘れてたので丁度いい
  - 最初復元用に配列で入力をセーブしとくのが必要かと思ったが入力含めた三要素をとっといてそれぞれソートすればいいってのに気づく
  - 2019/08/23現在まだatcoderの言語アプデがきてないのでpython3の辞書は順序が保存されない点に注意してソートして最初なんか間違えて1WA
  
#### 114
C
- 「うまい具合に3, 5, 7でスイッチする方法わからんな〜」
- 解説みたら**3or5or7が含まれてるやつ全列挙してあとで全て含んでるか判断**というマジかよってなる手を使うとのこと...oh...
- 実際それでもせいぜい29523個しかないのでソートして探してまでやっても余裕で間に合うという...してやられたわ
#### 118
C
- 観た感じGCDの匂いがするがぜんぜん考察も証明もできず
- まさかなハハッとか思いながらGCD書いたら通った
- 解説読んでも理解できん
- というかそもそもGCDが証明できん
#### 119
C
- もうわけわかんねぇからググったわ
  - 難しい部類に入るらしい
- Nが小さいので実は全探索と気づける
- A,B,C,不採用の4つの状態をそれぞれのやつにもたせて、答えはA,B,Cとの差の絶対値でどれだけインクリメント/デクリメントすればいいかわかる
  - そんで最小値を更新していく
- ってとこに気づいたところで実装も悩む 再帰書けないマンになって死
C
- たぶん1年ぶりくらいに解いた
  - ぼんやりと実装は憶えていて、Nが小さいので全探索の気持ち
  - DFS, やっぱり`min`で比較するときに`rec+point`で得点追加したほうがわかりやすいね（DPの実装の気持ち）
- 前回のrubyでの実装がrubyらしさあってgood
  - Pypyでやった なんか4倍くらい遅いんだが？

D
- むずい
- にぶたんが使えそうだけどクエリがあるから`O(1)`?みたいな愚考をしてしまう
  - 実装はせず2,3分くらいで解説見た
- 愚直に毎回直近の2つのs[i]とs[i+1]、t[j]とt[j+1]をにぶたんで出してこの8通りを全探索。
- Python・PyPyではTLEになった。同じ内容をGoで書いて通す
- すげぇ時間かかった....


#### 120
C
- Streakのために簡単なやつを解いた
  - 最終形態は0000か1111かなのでmin(one, zero)*2

#### 121
B
- やるだけ
  - [「緑くらいの難易度」](https://kenkoooo.com/atcoder/#/contest/show/1209acf0-66e0-4eec-9f2e-cccbdc636578)からきました
C
- できるだけ安く済ませたいのでAiで貪欲です おわり
  - なーにが終わりじゃ 3WAくらいした
  - テストでの`print`消しわすれ2件, **Aiが複数回登場する** を見抜けなくて1WA
  - Streakのために簡単なやつを選んだはずなのに死

#### 122
A
- はい

B
- はい。Nが小さいので全探索

C
- Nが大きいので累積和作っといてクエリはO(1)にする
- 3ヶ月ぶりの挑戦。
 - Atcoder ProblemsのProblem ListのDifficultyで低かったので。
 - うっすらと見た覚えがあったのでなんとなく累積和した。rbのバージョンがクソでよくわからんエラー吐きつつもチューニングしてAC

 D
- ちーともわからんので解説みた
  - 解説読んで悔しさがあふれる問題 適性か？
- 過去3文字ぶんで再帰。3文字で条件を満たしてしまうのは`AGC` `GAC` `ACG`, 4文字だと`AxGC`, `AGxC`
  - 3文字分を全探索してれば被りなくすべてを網羅できるのでそうする
  - 解説の実装がクレバーな感じがする `TTT`, i=0でも結局nの長さになる（ように関数を作っている）ので心配ない、とか
  - なぜか手元でやったときは無限ループを作り出してしまい、paiza.ioで書いたら素直に通った...
    - 謎すぎる（見返してない 一応コメントアウトして残してあるので未来の自分が気になったらたぶんみてくれるはず）
- 間に合わないので雑にメモ化再帰するDP 雑でいいです


#### 123
C
- ボトルネック

#### 124
C
- 2ヶ月前にやったばかりだったわ
  - Streakが途絶えそうだったので慌ててDifficultyの低いやつをやるという。。
  - そっちのコードはなかなかクレバーだった。最初の文字をキーにして探索するやつ
  - 今回のはインデックスと`b`or`w`の4通りを毎回試す感じで解いた
- 最終状態が一意に定まる系の問題は、実際にやってみるといいかもしれない

#### 125
C
- ~負数の数は0か1にできる + 場所は移動できる~
  - ↑ たぶん問題違う
- 100回くらい挑戦したけどそのたびわからなくて解答見て理解した気になって1byteも書かずに忘れるのを繰り返してた
  - gcd(arr) = gcd(a[0], gcd(a[1], gcd(a[2], gcd(a[3], gcd(a[4], ...)))))
  - と、変えるaの（変えた先の）値はなんでもいい = 無視していい、ということから考える
- などと書いたくせに「了解！」と思って実装したらWAだったのでマジでキレてる
- めっっっっっっっちゃ嫌いな問題 苦手じゃなくて嫌い マジでヤだ

D
- 任意の2つの符号を変えられるので、負の数が偶数か奇数かで、最終的に残る負の数は0個か1個にできる。1個の場合は最も小さい数を選べばいい

#### 126
D
- 「unionfindかな?いや木の高さしかわからんのでそれぞれの葉同士の距離はわからんよね...偶数同士なら最初に決まるのでそのあと奇数を埋める？でも時間がかかるよね...Nがでかいので隣接行列は作れないよね...」で2時間くらい悩んだ
  - 解説見たあと -> Lowest Common Ancesstor!!Lowest Common Ancestorじゃないか！！！！
E
- どうせ矛盾しないんだしz要らないのでは?
  - クエリで登場しない数 + クエリで登場した中で完結するグループの数
  - なんとなくunionfindでxとyだけみてやって最後に親をuniqする感じ
  - ダ  メ  で  し  た

#### 127
D
- 毎度ソートしたりにぶたんしたりする実装を試してたらしくそれは2回ほど挑戦してTLE撃沈してた
- 今回解説を読んで実装
- 要は **「書き換える枚数は確定できる」「cの大きい順にしたものでaの小さい順にしたものを置き換えるイメージ」** という、あっはい、みたいな感じ。ただし実装がなかなかやりにくい
- 尺取っぽくやってみました


#### 128
C
- 初見でやるのはちょい難しそう
- N, M<=10なので全探索の気持ちが生える
  - -> N個のスイッチについて0,1のすべての状態を想定し、
  - それぞれについてみたとき、各電球が条件を満たしているか都度判断する
- 2^Nのバイナリ表現をうまいこと（あとでMのあり得るべき状態と比較して判定する時に楽になるように）配列を組んでまあなんか好きな方法で作成する
- 数カ月ぶりに解いた。やっぱむずいだろこれ
- goでbit全探索した。bit全探索の練習にきました
  - ほぼ勘でやってて30分以上かかった気がする。こんなん10分で解けや
  - ```go
	for i := 0; i < (1 << uint64(n)); i++ {
		ok := true
		for k := 0; k < m; k++ {
			c := 0
			for _, v := range balbs[k] {
				if 1&(i>>uint64(v)) == 1 {
					c += 1
				}
			}
			c %= 2
			if ps[k] != c {
				ok = false
			}
		}
		if ok {
			ans += 1
		}
	}
    ```

#### 129
3完+Dの考察合格。全体的にやさしいというか、アルゴリズムはごく初級レベルでいける

C
- 一次元DP．ABC040でやったばかりだったのでまだ記憶にあった
  - いうて本番では頭がバグって一旦置いた
D
- なんとなく考察は出来たが実装にいたらず。終了後10分ほどで提出したものはTLE
  - コード自体に改善の余地はあるんだけど、そもそもpython(pypy)で解くのつらい？
  - にゃーん..
- ↑ から4ヶ月ぶりにやった 4方向の累積和ってのはすぐ生えた
- PythonではTLEでPypyではAC

#### 130
3完 C解けず 初めてコンテスト中にD解けた
C
- 本番で死ぬほど誤読してて、「最小値」かと思ってたので死んだ
 - ちゃんと日本語を読めば解ける最易問題
D
- ふつうに尺取法をやるだけっぽかったけど実装忘れたのでggって出てきたけんちょんさんのqiitaを丸パクリしたりした
  - Cに時間をかけすぎていたせいで提出が遅れてしまった...（本番）

#### 131
死のfloor(2.5)完
C
- 本番中は掛ける数をにぶたんで求めて、これは今でも謎だが最後のケースだけ失敗してた
  - 死
  - 解説一瞬みて生えて死にたくなりながら書いたがサンプルが通らず死のうかと思ってた。
  - B-Aじゃなくて B-(A-1) Aは含むので
- 久しぶりにやった 包除原理は覚えてた
  - **B-Aじゃなくて B-(A-1) Aは含むので** これできなくて死んだ
D
- 締切が近い順にやる（締め切り時間が同じならその中でかかる時間の順番は関係ない）

#### 132
初4完だけどやっぱ相当易化してるので...
C
- Cの中では最弱
  - ソートして真ん中ふたつを比較して終了
- 2019/11/18 解き直したら実装できなくて死ぬかと思った
  - 退化してる 死にたい

D
- 順当に数学的に解く。nCrで球を置く場所を取るのと、二項定理で球の選び方をとって掛け合わせる

#### 133
D
- サンプル2を試しに手で動かすと、適当に決め打ちした数で実際に確かめてみるのが生えた
- つまりにぶたんだ
- ただし偶数のみなのでmidの取り扱いがめんどくさい（頭悪いの？）
  - あとlとrの値もわかりにくい（アホなの？）
- 5時間かかった（は？）

#### 134
C
- 2回目のチャレンジらしい 問題文読んだら微妙に解いた記憶があるようなないような
  - 前回はACしてた
- 最大値と二番目に大きい値を保存して丁寧に更新していく感じ
  - たぶん前回も同じ感じで解いたはず 
  - 前回はわざわざインデックスも保存してた気がするがそんなもんは必要ないね

#### 137
D
- むっずい 解説見た
- 解法以前の発想の元としては、**頭からみていくとどんどん制限がきつくなっていく感じがあるので、制限の厳しい方からみていく**というのが常套らしい
- この場合はたとえば**残り日数が1のときはAi<=1のもののうち最大のBを選ぶ**ということになるのでつまりうしろからみていこうねとなるらしい
- その時点での最大値を追加アンド取り出しをするので優先度つきキューが生える
- と、そこまで教えてもらってもどうやって実装するのかわからんかったのでググった
  - 日数をキーにソートして、heapqを用意して、`i=残り日数`にしてソート済みリストから条件に合うまでheapqに追加、条件にあわなくなった時点で`pop`したものをresultに追加、みたいな感じ
- うーんこれむずい Difficulty妥当 だけど実装例は理解できるレベル
- このくらいを適性にしたいね...

#### 138
D
- 4ヶ月前もやってたらしいがそのときは通せなかったっぽい
- 単純にBFSだが次のノードに移るときに今のポイントを加算していく累積和のエッセンスもある
- コンテスト終了後に追加されたテストケースにより1WA
  - 回避どうしようかなーと考えたが、ふつうに双方向に行き来できるようにして訪問済みのフラグを用意するだけだった
  - Difficultyが低いので喜べない
- 2ヶ月前に解いたばかりだというのに「愚直にやって間に合わんわコレ答えみるか」と諦めて解けず、さらには隣接行列でやってしまったおかげで無駄にTLEとREの山を築いて死亡。あたまがわるいから退化してるんだね。
  - ちゃんと問題文を読めば**根が1**とあるので、最初にクエリの前処理を該当のノードに対してやっておき、最後に一度だけDFSを走らせて更新していくというのがわかるだろうが 馬鹿か？


#### 140
C
- nとn+1を見るので後ろからみていく、という発想が生える
- `b[i] = min(a[i], a[i+i])`だと思ったら`b[i] >= min(a[i], a[i+i])`だということに気づく
- つまり毎回iだけでなくてi+1も更新する、といけるのでは?
  - -> いけました

#### 141
C
- atcoder problemsのdifficultyにしてはなんか難しくない？？？？
  - 自分以外なら引かれるので、自分以外だったときの総数を引く（ので、保存するのは結局自分のときの回数）
  - 酔ってるので上限値が大なりじゃなくて大なりイコールになってて1WA

D
- 最初毎回ソートしてやっててTLEなってた
- 優先度付きキュー知ってるかどうかじゃんねこれ 知ってたら秒で解ける


#### 142
C
- 新レートのCで最弱
  - サンプルをみれば自明 終了

D
- サンプルケースみたら約数のうち1と素数の論理積から2つ選ぶんじゃないのと思ったら論理積の長さだったんだけど、なんでなのかは不明
  - ??????????????????????????????????????????????????????
  - サンプルケース2って`1 2 3 5`なんだけど`1 2` `1 3` `1 5` `2 3` `2 5` `3 5`の6つじゃないの。。。？
  - 謎 百回は読んだ 謎
  
#### 143
C
- しゃくとりでやった

D
- 何度目かのチャレンジ
  - 何度もやってて解説読んでるのに今まで実装できず
  - というかふつうに実装しても混乱する
  - Difficulty不当なほどむずい
  - にぶたん
- ソートして3辺のうち最長のやつを見つける。
- for二重にしたあとそれぞれのインデックスの要素の和で`lower_bound`を貼って得られるインデックス-1までのやつ
- というだけのはずなのに何十時間かけてんだ
- ちなみにこのやり方だとPython3はTLEでPypyだと1960msくらいでギリ通った

#### 144
C
- `a-bが最小となる、a*b=nを満たすa,b(a>=b)`を見つける作業。
- 素因数分解してすべての組み合わせで2数を作って...と考えたけどあきらかにダルい
- ダルいので全探索。1から順に割って、割り切れた数をbとする
- 10^12とデカイが、`a*b=n(a>=b)`と考えた時、`a*a>=n`だし、せいぜいaは平方根までの探索でいい

D
- コンテスト中 当然のように解けず。たぶん一撃で解こうとなんかしてた
- 再挑戦（いつかは不明）、たぶんコンテスト後のTLを眺めていたはずだが解けず。どういう感じでやったかは不明
- その後 n回挑戦。`m（n<m）`回目で解説を見てにぶたんということを知るも実装せず。
- さっき n+1回目の挑戦。今までの記憶をうけ、10分ほどソラで、その後すぐ解答を見て、さらにはggっていくつかの解説を読むも、**5時間後、まっっっっったく実装できず、解けない。**
  - マジでお前向いてないからいますぐPC捨てろ
- 実装むっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっずい、つーかわっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっっからん
- ということでここ十数時間かけてやってた
  - 紙に書いて解けたらなーんだという感じだが.....
  - `atan`なんて知らんのでふつうににぶたんで求める。
    - 他の人の解答は当たり前のように`atan`ばかり並んでいたしググってもそんな感じ
- 実装のむずさ+発想のむずさ。場合分けして三角形の面積をにぶたんで求めた角度をもとに導出し、比較し（この比較が場合分けとセットになってる）、更新していく。
- コンテスト中これを半分以上の人間が解いてたらしいので、は？？？？？？？？ってなった

#### 145
C
- 本番で問題を読み違えて無限にバグらせるし実装もバグりやすい書き方してたのでダメです
- ふつうにpermutationでループするだけっすわ
- Goで解き直し next_permutationをわざわざ実装するのにめちゃくちゃ時間がかかった
- 一週間ぶりに解き直し、つーか[「緑くらいの難易度」](https://kenkoooo.com/atcoder/#/contest/show/1209acf0-66e0-4eec-9f2e-cccbdc636578)からたまたまきました
- 今回はnext_permutationを使わず、再帰で解いた。
  - したら、なんか微妙に遅くなってる...なんでだろうね

D
- 落ち着いて条件から読み取れることを列挙していこうね
  - 一回の操作で3ずつ進むのでx回目の動作は3で割り切れる数（思いつかん）
  - 一回の操作で3ずつ進むので操作回数の合計は`(X+Y)/3`（oh.....）
  - (1,2)と(2,1)のそれぞれの数は単純な連立方程式で解ける（はーーーーーーーーーーんｎ）
  - nCrで解ける（それはそう）
- なのだが、ただのnCrを貼ってMODしただけだとなぜか最後のサンプルケースでWAになる（は？？？？？？？）
- `nCr mod p`を貼るといけた 原理とか、なんでそもそも↑のやり方だと駄目なのかとかは一切わからん
  - [](https://qiita.com/derodero24/items/91b6468e66923a87f39f)

#### 147
C
- 令和C最難とかいわれてたやつ
- bit全探索なんだけどbit操作がいくらやっても覚えられないので愚直に配列でやった
  - あとでbit全探索バージョンもやる
- ...までは楽なんだけど問題は判定とデータ構造をどうするか
  - ハマるとDFSとかやりだす 虚無
- 結局答えみたんだけど、bitは決め打ちなので、全員の発言と照らして矛盾が発生するか調べる
  - ...は分かるんだけど実装の見当すらつかんよね
- ただしくは「発言では1だけど決め打ちは0」or「発言では0だけど決め打ちは1」をはじく、でした
- 探索寸前に、そもそもいまみてる決め打ちのやつが0ならばどれだけ探索してもムダなのでcontinue、もやる
- むずいっしょこれ


#### 148
E
- 数学
  - **二重階乗** is 何（コンテスト中はググりすらしなかった）
- 最初考えてたやつ
  - ```
    奇数は0にならないのは自明
    2桁まで(10~99)なら10,20,...90の9回、0がつくチャンスがある
    3桁までなら1(10,20,..90), 2(10,20,..90)..9(10,20,..90)に加えて,
    100,200..900が0は２つ増える
    これを再帰
    ```
    で考えていたが実装できず死亡
- 解説をみたら`10で割れる数ごとにいくつか0が増える->10を2と5に分解して、どうせ2はたくさん出るので5で割れる数を数えればいい`とのことで、は？？？？？？？？？ってなった
  - youtube解説はまっっっっっったくなにをいってるのかわからんかった
- 要はNの素因数5の数を数えたい（なんで？）
- N/5, N/(5^2), N/(5^3)... と数えていく。5の登場回数が欲しいので25は2回だし125は3回なのでループで乗数を増やしていって割って商を足していく
- 実装としては`2*(5**i)`でやったほうがわかりやすい（最初は10から始まるので）
- とか書きながら結局わからんのですが??????

#### 149
D
- 1秒で解法が浮かぶも、最初の実装の「k回前が同じだったときの状態管理」がクソクソのゴミだったせいで激冷え
  - わざわざグーチョキパーの3つぶんを管理してた 無限if
- 考え直して、すべての状態をboolで管理することにしたらうまくいった
- クソクソのクソ 世界一あたまがわるい 歴史上最も競プロに向いてない キーボード折れ
- 本番がなぜか謎に20時開始で、自分の環境により9時過ぎにしか参加できず、参加しようとTLみたらunratedだったので、テキトーにやったんだけど、最初の着想のゴミ実装のせいで30分以上かかったわ

#### 150
C
- `next_permutation`をライブラリにつくっときゃ一発 はい

#### 151
C
- シミュレーションだけど日本語読解
- WAカウント用配列とACチェック用配列でいいね

D
- 典型BFS
- 本番中、頭がバグってしまい、2重ループの中でスタートを設定したあと、更に2重ループでゴールを設定して無事TLE
- Difficultyが高い気がする とはいえ解けなかった雑魚なのでもうなにも言う資格はない

#### 153
D
- コンテスト中に通せた
- みるからにDPなのでその方針でいく メモ再帰
- 適当にこねくり回していただけなので見返してもなんでこれで通ったのか理解できないね
  - ```python
      tmp = f(x // 2) + 1
      dp[x] = tmp
      tmp += tmp - 1
      return tmp
    ```

#### 158
本番中4完7WA（B1D6) めずらしくデータ構造オンリー非アルゴリズムでDまでいける
C
- 適当に`10^6`までで全探索して終了
D
- いちいち反転させたり文字列でやるとTLEなのでLinkedListかdequeでやる。回転した数を憶えておいて適切に振り分ける
- sと前と後ろでやったが、sと後ろは合体させて右と左でやってもいいらしい

#### 159
A
- 参加できなかったんだけど「解けなかった」「300相当では」というtwを見かけてわくわくしながらDifficultyみたら灰底辺だったので不思議に思いながら解いてみた
  - 考察して実装してテスト全ケース通るまで5分くらい 無事一発AC
- 以下考察
  - 1って書かれたM個と2って書かれたN個があるよって感じのncr
  - 「N+M個のうちM個のうち2個」だとわけがわからんので別の方法を考える。
  - 全体から奇数になるやつを引けばいいかもしれない ncr(N+M,2)-ncr(N, 1)-ncr(M, 1) = ncr(N+M, 2)-(N*M)
  - いけました
B
- 先頭から真ん中ひとつ手前までと、真ん中からひとつ先から最後尾までもそれぞれ回文であればいいですな
  - で、全体が回文なので、「前者」と「後者をリバースしたもの」を比べるだけでもいいのでは、という気がしてきたが試してません

C
- サンプル見るとx,y,zぜんぶ同じ数、つまり立方体を作ればいいのではという気がしてくるのでそのとおりにやってみたら通った

### ARC
#### 002
B
- 日付モジュールの使い方練習ですかね
  - 仕様をググりましょう 終了
  
#### 003
B
- ARC Bの中で最弱
  - やるだけ。もとのやつと逆順をセットで持っておいて逆順でソートして順番にもとのやつだけ出力

#### 005
A
- まだABCのC==ARCのAじゃなかった時代？
- 考察1秒 実装10秒
- アルゴリズム以前なので誰でもいけますが0点相当だと思いましょう
 - 言語によるけど3分岐するよりかは入力を変形したほうがいいよね
 #### 007
 A
- まだABCのC==ARCのAじゃなかった時代？
- 例によってアホほど初心者っつーか入門者向けの難易度0
- 回答数を稼ぐためにこんなん解くの情けなくなってきた
B
- 問題文は読んでもわからんけど図とサンプルを眺めたら適当にswapするだけだとわかり、N<=100なので毎回配列を探してもまあ間に合うってのに気づくのでそうする

#### 008
A
- これ問題読んですぐ考えるべきは**3パターン**って気づきますか？ぼくは気づかくて30分ほど寝かせました
- 1個ずつ買う場合と、10個単位+1個ずつ買う場合と、10個ずつ買う場合

#### 010
A
- はい
- 書いてあるとおりにやればいいです
#### 013
B
- 解法はわからんけどサンプルを眺めると、横でソートして縦でmaxとればいけるんじゃねとかが生える
  - 考察ゼロ
  - サンプルがやさしい 令和ABCならありえない


#### 016
B
- 番兵法の練習ですかね？
- テクニカルな面としては、縦nじゃなくて横9で考える感じ。番兵を最後におけば楽
- 実装的にもサブ言語の練習にちょうどいいかもしれない 配列とforとwhileの使い方みたいな感じ

#### 030
A
- 最初` k 個の連結成分のみが残ったグラフ`の意味を取り違えていて、単体のノードだけ残すのかと思ってたが、サンプルをみたら違った。連結しててもいいのね
- ということでNの半分よりより大きいKは作れっこないことがわかる。
- ARC-A最弱？

#### 031
B
- 探索系DFS典型
- 10x10なのですべてのマスに対してシミュレーションする
  - なんか入力がおかしい？最初にタブが入るんだけど？
  - あとpython3の多次元配列のコピーが罠でshallow copyになってしまうということに気づかずムダに時間を浪費した

#### 040
A
- シミュ
- 書いてあるとおりにやればいいです
- とくにアルゴリズム的な知識は不要で、配列ができればいいです

#### 041
A
- アルゴリズムじゃないけど条件分岐をどうやって捉えるか、あるいは捉えないか、に尽きる
- 自分は適当にでっちあげた3,4個の分岐の結果を手元の実験を経て2つだけに絞った
  - こんなんをサクッと構築できるのはどういう脳内構造してるんだ
- アルコールチェックに使えるような問題？


#### 042
A
- 令和ABCでいうとCでDifficulty600くらいじゃない？なんかちょうどいい問題
  - 半年くらい前にアタックしたときは愚直でやって通らなかったっぽい
- サンプルを眺めても気づくが、あとから更新したやつが優先されるので入力を後ろからみていき、すでに出たやつは無視し、最後に出てなかったやつを昇順で出力する
- 難易度適性

#### 043
A
- Dificulutiy低いからきました
- 最小値と最大値がわかればpが導出できるのであとはそれをもとにqを導出する
  - すげぇ雑に実装したけどなんとなくあってた

#### 044
A
- 素数かそうでないか、そうでないなら条件にあうかどうか、二回判定するだけ
- 久しぶりにruby使って解いたら文法もメソッドもなにもかも忘れていて2WA
- `Prime.prime?`を使いたいだけだった
#### 049
A
- はい

#### 051
A
- なんか何度目かの挑戦らしくて、前回かいたやつは「全探索する」とかメモっててこいつ馬鹿か？となった
  - グリッドじゃないんだしするわけがない
- 塗ったときのパターンを考えた。4パターンあって、条件から確実に「赤もしくは青で塗られた範囲が存在する」ため、答えに`No No`は存在しない
- 考えるべきは一方が他方の全体を含む場合、これは2パターンあって、矩形が円を包含、もしくはその逆である
- 前者は簡単で、単に矩形と円の一番外側となる範囲で比較すればいい
- 後者はすこしひねっていて、同じように外側の範囲で比較しても、**矩形の角だけが円からはみでる**場合があることにきづく
- なので比較するのは**矩形の中心からそれぞれの角の距離と円の半径r**。これがすべてr以下ならば矩形は円の中に収まっている
- なんかこういうダルい計算は雑にpythonで書いたほうが良さそうな気がする

B
- まったくわからんので実験したら、素数同士でカウントが大きくなる。ただし2数の素数の差での関係はわからず。
- 計算結果を途中で出力すると(a,b)=(0,1)<-(1,2)<-(2,3)<-(3,5)<-(5,8)<-(8,13)...`(b,a+b)`みたいなことになってることに気づく
- ので、これをやって数えた。なぜこうなるのかはわからん
- なぜかこれだけなのにカウント数えるのにミスって1WA
- しかも実験と検証と実装にアホほど時間かかった あたまがよわいからしかたないね むいてないね

#### 053
A
- 最初かんがえたやつ
  - `w==1||h==1`と`w==2||h==2`とそれ以外でわけれそう、最後のそれ以外のやつを考える
  - 最後のそれ以外のやつは「角」と「角を含まない枠」と「内側」でいけるんじゃねと思ったがこれは完全に間違いです
- 横に2つ並んだものを縦に並べるの+縦に2つ並んだものを横に並べるもの、という敷き詰めで考えたほうがわかりやすい
- 2WA、6分ほど
#### 054
B
- はじめての三分探索
  - さっぱりわからんので解答みた
    - みたうえでさっぱりわからんので写経した
    - 理解したとは言ってない
  - まずもって式の導入がむずかしくないですか
  - そのうえで下に凸のグラフを思い描け、かつ三分探索を知っていれば解ける...?
  - 微分してから二分探索する方法もあるらしい?

#### 057
A
- どうすっかな〜〜って唸ってたんだけどよくよくサンプルみたらすげぇちっさい
  - よくよく考えたらk=2で倍々マンだし最も小さいa, k = 1, 1でも40回はやれば終わる
  - k=0のときはインクリメントになるので引き算
#### 079
A
- 中間を訪れたかどうかもっておいて判定
  - 自分は配列1つだけにしたが、解説みるとtoとfromのぶん2つもっておけばもっと楽だったらしい
#### 080
C
- ARC-Cの中では最弱
  - 奇数の隣は必ず4の倍数
  - `1 4 1`はOKだが`1 4 1 2`がアウトなことに注意して4の倍数と奇数の数を数える
#### 091
A
- 奇数回裏返れば裏になってるので偶数回裏返る場所をはじき出す 

#### 093
A
- 差分取ればいいんだけどその利用の仕方があんまりうまく浮かばずハマった
 - 解説pdfは読めないのでqiitaで適当な記事を探して読んだらわかったけどかんたんすぎてアになった

#### 097
C
- ABC097Cと同じだってのを解いてから知った
  - あ、 [「緑くらいの難易度」](https://kenkoooo.com/atcoder/#/contest/show/1209acf0-66e0-4eec-9f2e-cccbdc636578)からきました
  - 感想はABC097に付記しときます

### AGC
#### 002
B
- 最初単に伝播していくだけかと思ってたけど、球がなくなる可能性があることに気づく
- 実装が下手クソで1WAしたけど、1ターンでとりあえず球が移動するってのをちゃんとやるとできる

#### 005
A
- AGC Aの中では最弱
  - 今だと100点くらいの問題
  - SはストックのS ストックが続く限りTを消せる
- AGCの中では最弱と言おうとしたが最初「ソートした真ん中1/3」だと思いこんで自信満々で出してアウト
  - ソートして「上位から順に1位２位」「下位から適当に3位」で1セット*nが正解
- 4ヶ月ぶり２回目
  - だいたい同じ解き方
#### 006
A
- 酔ってるときに解こうとしてなぜか解けなかった（酔ってるからだね）
- sの先頭x文字とtの先頭x文字ぶんをとった部分文字列で最長になるものを保存・結合


#### 007
A
- 右か下にいく一筆書きでいけるかどうか
- 右と下の両方に"#"があったら駄目、ゴールしたときにゴールに入った方向と別の方向に"#"があったら駄目、一筆書きなので入力時に"#"の数をとっといて最後にstep数と照らし合わせる、など
- 世界一競プロが向いてないので2WA

#### 009
A
- なんかgit addしてないんでわかんないけどいつかやってた（そして途中で放棄してた）っぽい
- 前のやつは後ろのやつをいじれないので、うしろのやつから確定していく方針で見事AC

#### 011
A
- 乗せれるだけ乗せる
- なんでこれ10秒で解けないの？
  - 世界一頭の悪い実装（二重while）してた
  - 風呂入って飯食ったら単純に`for`だけでいいじゃんとなりそのまま実装してAC

#### 013
A
- `i i+1`で比較するシミュレーション
- 状態を適当に「増加」「減少」「未確定」で判断して、「増加」->「減少」またはその逆だとans+1

#### 014
A
- シミュだなと気づくのおそすぎて60分くらい溶かした
- all sane odd の場合のコーナーケースが取れず30分くらい溶かした
- 死にたい

#### 015
A
- AGC Aの中では最弱
  - 4WA...
  - 最小値\*n-2~最大値\*n-2で1ずつインクリメントしたものが網羅できる
  - n > 1,  a < bが条件になってないという小賢しい罠
B
- AGC Bの中では最弱
- 必ず1回か2回で行ける
- 今より左と右でどっちかがそれぞれ1回、2回で行ける

#### 016
A
- アルファベット固定で全探索典型なんだけどめっっちゃくちゃ実装しにくい
- 10回以上アタックしてやっとできたけど出来た気がしない

#### 017
A
- 偶数と奇数の数で決まるのでnCrをがんばる
  - P=0 -> 奇数を偶数個といくつかの偶数個
  - P=1 -> 奇数を奇数個といくつかの奇数個
- なんか無限にWAを生んでしまい、そのたびにアドホックな追記をしていったので、正直コーナーケース以前のケースでどんな場合分けするのが正解なのかわかってない

#### 019
A
- こういう問題苦手
- 単純に2L基準の最小値、奇数Lなら更に1L基準でやったやつの最小値を加える

#### 020
A
- Streak用にDifficultyの低いやつをテキトーに選んだ
  - いずれの操作によっても初期位置から変わる互いの距離は2で割ってなるか1なるかどっちか
  - 仕方なく負ける瞬間を考えると、相手に踏まれる場合になる。これには相手が横に立っている必要がある
  - なので、先に横に立たれたら負け
#### 021
A
- 8か9で埋めればいいと思ったけど9だけでいい
- 996と699の結果は変わらないので先頭だけ-1して残りは9でいい
- ただし199とか、オリジナルが最大の場合もあるのでmaxを取る
  - これを忘れて2WAした

#### 022
A
- 2,3週間に5回はアタックしてるんじゃないの？
  - いまだに解けず
  - 解説みても実装できないってマジで向いてないんだと思う  

#### 028
A
- 10回以上アタックしてようやく倒した
- 落ち着いて考えて手を動かすと実際に試してみる方法が浮かぶ
  - 答えが存在するならば最小公倍数になりそうだと気づく（証明は知らん
- まず最小公倍数の長さの配列をターゲットにし、所与の式からSの該当する文字を割り当てる
- 次にTを同じように割り当て、すでに異なる文字で埋まっていれば`-1`
- ... というのを考えたが、内包表記でTLE, `[0]*lcm`でREになった
  - forを2回回しているので`O(N+M)`だと思ったのだが...?
- で、配列を作ってるところで駄目になってると気付き、配列ではなく辞書でやるとACになった

#### 029
A
- 最終形態から考えるとWの移動距離になる

#### 031
A
- 最終的な登場回数だけで決まりそうな気がした(登場回数+1をしてぜんぶ掛けて最後に空文字ぶん1を引く)
- なんでかというと、同じ文字は含まないので、結局登場する順番は関係ないから。ある文字が複数あったとき、ひとつだけ選ぶ（あるいは選ばない）というのは、「どの時点で登場した文字を採用するか」と同義。
- これを10秒くらいで思いつく連中は頭の中どうなってんの

#### 039
A
- n時間かかった....
- 方針はすぐに立った
  - こういう問題はまず「単体の場合」「連結した場合」でどう変わってくるか考える
  - 先頭と末尾が異なるなら単体の場合をK回やればいいだけ
  - そうじゃないなら「左端」「両端の連続する同じ文字を省いたもの*K」「両端の連続する同じ文字をつなげたもの\*(K-1)」「右端」で足す
- いろいろバグらせていた。。。正味3時間くらい...

#### 041
A
- 本番、ルール無用の5WA投げ出しでパフォ-60で死んだ（1ACしなければ反映されないと勘違いして酒のんで途中で寝た）
  - アホですか？
- 待ち構えるより折り返して会いに行ったほうが早い

#### 043
A
- 最初の100分ほど「DFSして`#`の最小回数じゃねぇの？」と本気で思ってて問題文を読み飛ばしていた
  - しかしここでDFSしてたのでそのあとの再考やコード改変が楽であったことは留意されたい
- 正しくは、上記のように考えた場合、各最短経路上の連続する`#`の数、であった。
- きりみんちゃんが通してたっぽいツイートを、80分くらい経って諦めてたときにtwitterみて気づいて、なにくそと奮して再考した。なんでこの再考が最初から出ないんだろうね（4WA125分）

### 外部コンテンスト
#### JOI2011 yo
E
- 1->2-> ... N-1->Nという順にやっていくBFSで最短パスを加算していく
  - 典型BFSでやること増えただけ
- 見積もり的に間に合わなそうだけどよく読んだら制限時間が10secなので間に合う
  - 雑にPython3で実装したやつが7.2秒だった
  

#### JOI2019 ho
B
- にぶたん、むずい
  - AOJにあったC++のやつを写経しただけになってしまった

#### COLOCON -Colopl programming contest 2018- Final（オープンコンテスト）

A
- 前後にAが含まれない場合とAだけの場合とそれ以外の場合で場合分けしたんだけどこれはクレバーではない（TLE, WAを経てのAC）
- 解説が死ぬほど分かりにくい。他の提出を参照するもなんかよくわからん
  - 境界の数？？？？？？で判断？？？？？？？？？？
- Aしかない場合の`(x*(x+1)//n`ググった 数列の和か
- 累積和を使ったがコレ以外の方法が思いつかん
 
#### 第二回全国統一プログラミング王決定戦予選（nikkei2019-2-qual)

B
- 最初Dは距離かと思って、以下のような場合にサンプルコード1の答えが3になるので間違ってんじゃないのと思って2時間くらい溶かした
  ```
  (1,2)(1,3)(2,4), (1,2)(1,3)(3,4)のほかに、すべて独立して(1,2)(1,3)(1,4)
  ```
- よくよく読んだら`2 頂点の距離とは一方から他方への最短路に用いられる辺の個数を指します。`と書いてあったので、独立しているのは間違いだと気づく。距離じゃなくてそこに至るまで経たエッジの数だった
- その間違いに気づく前に基本的な方針が立っていてこれがわりとあってた
  - 連結していると考えた時に数の小さいほうに数の大きいほうがくっつく（ソート&&カウント）
  - ので、n個をm人に割り振る場合の数みたいなもん（割り振られない場合もあるので、4個の飴を3人に割り振ると考えると、各飴に3つの行き先があるので`4^3`になる、とかそういう）
- 0になる制約があるんだけど、**最初だけ必ず0で、そこ以外に0は登場しない**しか思いつかなかった
- 重要なやつがあって、**ソートすると必ず順番どおりに数が登場する**すなわち飛び飛びになっていない、というもの
  - 必ず直前の辺が存在する（何度もいうが距離ではなく辺の数なので）
  - わかりにくい
- あとは順々に掛けてやるたびにmodを取る。逆元が必要かと思ってたけどとくにそんなことせずに通った

#### Code Formula 2014 予選 Code-formula-2014-quala
C
- 脳死ループする前に最大値を確認すると間に合いそうにない
- うるう年の数え上げと差を求めるのにそれぞれ包除原理を使う感じの包除原理入門セット

#### Code Formula 2014 予選 Code-formula-2014-qualb
B
- でかすぎるので文字列でやって偶奇の値をそれぞれ足していって最後に比較する、っていうか、問題文のとおりに従うだけ
  - 11の倍数の性質初めて知った へー
- なんかしらんけど長さとインデックスの扱い？でバグって、仕方なくアドホックに解いた。なんなんだろうね


#### Code Formula 2014 本選
C
- 見た感じダルいけどまあやるだけ
- `@@@@@ffa@iia@@@@ia@@@fia@@ifai@@@@@@`みたいな連続する@が邪魔なのでしゃくとり法でやったが少しオーバーキルみがある

#### CODE FESTIVAL 2015 QUAL A
C
- 一見典型DPをしたくなるがTがでかすぎる
  - ということで解説見た（死）
  - 単純な貪欲としては難しすぎる
- **一旦すべてBiを使い、そのあとT以下を満たす限りAiを使うものに置き換える。置き換える対象はAi-Biを昇順ソートしたものを順に（T以下を満たす限り）採用していく**というもの。天才かな？

#### CODE FESTIVAL 2015 QUAL B
C
- 一見DPかと身構えるが、上記のqual2015Aをやったあとだと **「これも貪欲じゃね？」** との気持ちが芽生える
  - そういった主観がなくても、こっちのほうが浮かびやすい貪欲な気がする
- 部屋の容量の大きい順に、客数が大きい順をぶつけていく
  - 実際これでちゃんとできたので、300点くらいのレンジでは貪欲や全探索を考えるようにしましょう（戒め）

#### CODE FESTIVAL 2016 Final
B
- 「最大値を求めればあとは再帰的にいけそう？」
  - 「n/2が最大値っぽい？」-> 「いや、15だと[1,2,3,4,5]でいけるので違うか。。。」
  - 「じゃあいいや 愚直に1から足していって最初に越えたところが最大値っしょ」->python3でやったらTLE
  - 「うーんじゃあpypyで...」->通ってしまう
- 解説を観たらこんなことしなくてもよくて、最大値を求めたあとにO(1)でいける。。。
  - 発見されるまでのうちに必ず不要な数が1つだけ含まれている（もしくは存在しない）のでそれを省く
  - 差を取れば、それ。
- 難しかった...
#### CODE FESTIVAL 2017 qual A
B
- しょうがくせいのさんすう ずをかけばわかるね
  - 1時間くらいかかったんだけど()
- 行列を選ぶときは上から/左から詰めて選ぶようにしても数は変わらない。あとは四角形の面積
- 頭が悪すぎた こんなもん5分で解けよ

#### CODE FESTIVAL 2017 qual C
B
- 小さいので全探索
- 全探索の練習問題にいいかもしれない
  - pythonだとジェネレータ使えるからこういうの楽なんだけど他の言語だとどうなんすかね
  
C
- なんか色々と試行錯誤したけど結局両脇からインデックスを走らせて異なる文字なら同じ文字になるまでインクリメント/デクリメントする感じにした
- 最初に答えが0の場合と-1の場合の判定を行う `len(set(s))==1`なら0だし回文できなければ-1
- 回文できるかどうか？だけなら、xを取り除いたものとそれを反転させたものの比較で可能
- しんどい（脳味噌の足りなさが）

#### square869129 Programming Contest #6
B
- 一見ぜんぜんわからんが40分くらい悩んで解けた 良問
- 一見そうは見えないけど全探索
- まず、愚のパターンを考えると、aの最小値より小さいところに入り口を置き、bの最大値より大きいところに出口を置くパターン。
  - 最も近い場所からも確実にabs(a-b)以上かかる
- -> 入り口と出口をa,bの中からそれぞれ選べばよさそう（なんでだろうね）
- という感じの全探索。

#### Tenka1 Programmer Contest 2017 天下一プログラマーコンテスト
C
- 見てわかる通りのいつものやつだが分数になっている
- `w=..`の形にしたいが、**割り算を含むようにしてしまうと浮動小数点演算で死ぬ**場合がある
- python3だとTLEになるのでPypyで出した

#### パ研合宿2019 第3日「パ研杯2019」
C
- にほんごがむずかしいが全探索
  - 外側の2ループ（~M)でふたつの曲を選び、内側の1ループ(~N)で歌った人の得点を更新し、最後までうたったら全体の答えを更新

#### みんなのプロコン2019 yahoo-procon2019-qual
C
- ゲキムズなんだけどDifficulty的によわよわ つまり俺はよわよわ 
  - コンテストからこっち何回アタックしたか分からん むずい
- なんとなく方針は`a<b`なら最初に1円溜まってから何回`b-a`を加えられるか、というところに収束するだろうと気づく
  - が、今までもそれは気づけていて、実装がクソだった
- 残り回数が奇数か偶数かによって、`b-a`するために2ターンを費やすか、単純に1を足して終わったほうが得なのかが分かれる
  - 2ターン費やしてる途中だと-aになるので
  

#### diverta 2019 Programming Contest
C
- Dificultyが低かったので。
- 繰り返し系は単体のときと連結のときと分けて考える
  - 単体で完結する（=**連結に影響しない**）ようなやつは最後に加えても一緒なのでテキトーに数えて終了
  - 連結するやつも、両端に作用するのか一方だけなのかで考える。両端は単にそれをつなげていけばいいので楽そう
  - あとは余ったやつを考える

#### DDCC2020 ディスカバリーチャンネルコードコンテスト2020
B
- 真ん中で帳尻合わせできそうだが左右でわけたときNが奇数ならどちらに真ん中を含ませるか?から始まる考察
  - とりあえず目指すべきは総和の半分に最も近い数で、↑を考慮して、どちらも試す。
  - 実装としては左から「総和の半分を超えないギリギリ」と「超えるギリギリ」を累積和して、それぞれ総和の半分との差をとる。残った右側も適当にsumして同じように差を取る。小さい方の勝ち
- 200点にしてはちょっと考察も実装もめんどくさげな感じがあるが？

C
- コンテスト中
  - なんとなく左優先のあと上優先で見ていくとよさそう？なので各座標をソートして...あーめんどくせ諦めた
- 終了後kyopro_friendsのツイートを見て実装
  - 1 各行を高さ1として埋める
  - 2 余ってる行（"#"が登場しなかった行）各列を上or下の列からコピー
- 何気に最初の**各行を高さ1としたとき**の実装がプログラミング
- むずい

#### キーエンス プログラミングコンテスト2019 keyence2019
B
- 200点問題だけど実装がキレイにいったので記念
  - pythonの文字列分割で、文頭と文末からうまく分けた
  - ```python
    for i in range(len(keyence)):
      if s[: i + 1] == keyence[: i + 1] and s[-i + 1 :] == keyence[-i + 1]:
          print("YES")

    ```

#### キーエンス プログラミングコンテスト2020 keyence2020
C
- コンテスト、だいたい9割が通してたのを真似してBを無視してやったら10回近く1WA出して1時間くらい溶かして終了
  - いやこれはおいおいおいおいおいおいおいおいおいおい
  - 最悪 ゲロ吐きそう
- 自分の実装は1とs-1を順番に出す方針でやったら駄目で、正解はsをk回だしてあとはかぶらないような適当な値を出す、なんだけど、自分の方針のどこがどう間違っているのかさっぱりわからず、アンチケースも思いつかない。は？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？
- すげぇムカつく

#### sumitrust2019
C
- なんとなく手元で実験したら法則性が見えてきたのと、ふつうにやっても間に合いそうなのでそうする
- 本番では9分で終了
  - 令和からのやつのCの中では最弱?
D
- 令和Dの中では最弱
- 本番では、たかだか1000通りというのは気づいたけどそれ以上の考察はできず、わりと早めに諦めた
- というのをPython3でやったらなぜかTLE たかだかN*1000なのに...
- pypy3でやったら普通に通った
- 三ヶ月ぶりに解き直した
  - 解いたことすら忘れてて死亡 2時間くらいやった気がするがTLEがせいぜい 死亡 完全に敗北 退化
  - 登場回数を辞書でカウントして数字2つをループで決めて数える、という方法 完全にダメ
  - なーにが最弱じゃ 自分の頭のほうが弱いわ
  - 全探索すべきは制限の緩い3文字（全部で1000程度）。というか答えが最大で1000になるってのに早く気づくべきだった...
- うーんこれやっぱむずいのでは

E
- Eの中では最弱
- 本番では、2WAを残して6回ほど提出したがダメだった
- 適当に毎回更新する。いま出てる色の種類の数（それまで出た0の数で適当にインクリメントするなど）してかけていき、最終的にどの数列のルートにどの色を割り当てるかをしてやる。
  - 罠らしい。**0通りが存在する**のでそれをやるなど。。。。
  - 卑怯過ぎる
- 判明。先頭が0じゃないのもあるが、**0が4回以上登場する**という邪悪すぎるパターンがあるらしい。これ問題文から読み取れるのって解説の解法がさっと頭に浮かんだ人限定じゃないか？？？

#### Atcoder Petrozavodsk Conest 001
B
- ai < biなら確実に同じ数にできる(同じインデックス同士だと1ずつ狭まるので)
- ai>biのときはai-bi回加算しなくてはならない 加算できる数はai < biの全てのiの(bi-ai)/2回分
- それぞれ数えて、加算できるぶんが多ければ勝ち
- 💯🎊🎉👍👌💪
- 素直に解けてうれC
  - Difficulty1000超えらしい あっそう

#### パナソニックプログラミングコンテンスト2020 panasonic2020
B
- 図はミスリードなので無視しましょう ぼくは素直にガン見して2,3分ほどロスしました
- 左上がスタートなので市松模様がみえてくる
- あと`H==1 or W==1`の場合を忘れていて1WAしました
C
- python3で1WA出してから浮動小数点演算精度が問題くせぇなと気付きググって`Decimal`たらいう組み込みモジュールを発見、実装。ここまで2WAと30分ロス。
  - Atcoder Google Search Contestですか？
D
- つまりsは最小の形をとるので`abba`とか`abab`とか`abbc`とか`abcb`とか`abac`ならいいんだけど`accb`とか`babc`とかは駄目（順に、すでに`abbc`や`abac`が存在しているので）
- Nが小さいので全探索したいがルールの記述がわからん
  - 最初の文字は必ず`a`
  - N=aiのときN番目は`a b c...ai`になる
  - くらいしかわからず、k-0思考止まりですね...

## AOJ
### Volumes
#### Volume0200
料金と時間をそれぞれコストとした別々のワ―シャルフロイドを毎回作成するのが浮かぶが、これ時間的に間に合うのか？ -> 間に合いました

