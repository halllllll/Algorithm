## atcoder
### ABC
#### 004
C
- 30回でもとの配列に戻るってのは見てたら2秒で浮かぶのでそれで丸めた範囲だけやる
- はい
 - 独自に余りをだしたらふつうにバグを埋め込んでしまったが問題文通り`mod 5`しましょう
  - `(i-1)%5`とかしててループしてしまってあぼーんなった(わかりづらい)
#### 006
C
- 解けず
  - いつものようにa+b+c=n, 2a+3b+4c=mとやってもダメ（TLEと、なぜかWAが生えてきた）
  - 解説は読めない
  - 他の回答をみるとO(1)でもいけるらしいがぜんぜん読めない

#### 007
C
- ただの超典型BFSなんだけど謎のバグで無駄に時間かかったし結局バグは回避しただけでまっっったく納得がいかない
- キレそう
- 結局はただの超典型BFS
D
- 超典型のdigit DPらしい
  - なにそれ
  - 調べた
- digit DPとかいうやつに初めてあたった。こういうことか
  - 理解するのに半日かかった
  - いうてどうせ典型しか解けないので理解できてないってワケ

#### 010
C
- はい

#### 011
C
- 0からスタートして3,ダメなら2,ダメなら1を加えてく
  - 加えるときにnを越えないという条件
  - ぜんぶダメならもうお前はダメだ
- カウントの上限と最初からn==ngの場合をちゃんと考えておく
- dp解があるらしいがまったくわからん

#### 012
C
- あんま解いても意味ないC
- 数学でもアルゴリズムでもデータ構造でもない さんすう

#### 014
C
- いもす法入門
- どっかでみたな〜〜っつって公式みたら問題例そのまんまっぽい感じのやつ
- 完全に忘れていたので一読した
- いい加減そらで書けるくらいになりたい..
  - 0WAだったけど自戒を込めて
- 3ヶ月ぶりに解いた。前回のは覚えてない
  - 典型imosが浮かんだ
  - n,a,b=1,0,0のコーナーケースでWAなるコードを書いてしまった...
#### 015
C
- nもkも小さいのでそのままDFSして見つけたら終了っていう脳筋
- DFSとxorの問題
  - xorは直近やった121Dで出てきたばかりだけどどうせ小さいのでなんも効率化せずに回した
- クソ寝ぼけてて頭が働かなかったのでこの程度の低レベルな再帰ごときに時間をかけてしまった
  - dfsの再帰のこういう形（ひとつだけの解を出すため呼出し元にreturnしたりはしない）っていうのは好きじゃない
- shit one.
#### 016
C
- 解説が一切わからん。は？最短経路？
- 適当に二次元リストで友達のIDを保存していくとなんかどっかで重複するっぽいんだけどわけがわからず、それもリスト取って確認したら重複してるやつ除けばいいっぽいのでそうしたんだけど原因が一切わからん
#### 019
C
- また問題文を読んでなかったやつ
  - 与えられる配列から[i]*2 = [j]になるやつを探すのかと思った
- domn
#### 026
C
- いや再帰するだけなんだけど。rubyがクソなせいでreturnの部分のクソ簡単なバグが取れずに数時間溶かしたのでキレ気味に追加
#### 029
D
- 「桁dpの問題」みたいなリンクからやった
- 解法ヒントがあればまあその程度って感じ
  - 1ってのがミソで、単に数えたものの総数なので最大でも桁ぶんしか無い
  - ので、メモリに乗る程度のメモ用テーブルが組める
#### 032
C
- 文字読めないから順序うんぬんを飛ばして読んでて、「ソートして頭からやればいい」と思い込んでた
  - キレて解説みたらは〜ん？となった
- 尺取法とかいうのを解説に沿って実装したが3ケースでTLEになる クソ
  - 積をいちいち計算してたらダメらしく、計算結果をもつ変数をもたせると3WAなる クソ
- 結局わけがわからんが、r == lとなったときにr+=1して結果を1にするみたいなことをするといけるらしいがまるでわけがわかりませんね、クソ
#### 034
C
- 数時間かけたが一切理解できなかったので諦め問題
- 俺たちは何回「こんなんDPでいけるやろ典型」とか言って挑戦して玉砕してるのか？
  - ついさっきやった（2019/03/05 23:36 戒め）
- フェルマーの小定理？？？？？？？？？なにそれ
  - ggって唯一納得のいく説明[https://www.surweb.jp/sur/faq/fermat1.html](https://www.surweb.jp/sur/faq/fermat1.html)
- 逆元？？？？？？？？？？？？？？？？？？なにそれ
  - なんで逆元を求めればいいのかさっぱりわからん無理。階乗の話じゃないの？
- 繰り返し二乗法?????????????????????????????????????なにそれ


#### 035
B
- `?`をカウントして最後に動かしても同じなのでそうする
- 最小値、0未満にならないようにするのと、差によって0か1か決まるので注意

C
- fuck. いもす法とか知らない。なんか頻出いうわりに初めて知った。使い方も実装も（この問題では）簡単だったけどたぶんいつもの典型以外解けないやつだろ
- あと解説文に騙されたが冷静に考えればi番目をi+1に加算ってのは嘘でiにi-1を加算だろうが

#### 037
C
- ↑C35ひと月前にいもすとか知らないと書いてたな、まだ1次元だけだが相当出てくるぞ > 1月前の俺
- 変形いもすであぶれたぶんを引いていく感じ
- 実装はなんか泥臭いというかもっと工夫できたんじゃないかな

- 4ヶ月ぶりに解き直した
  - いもす？普通に累積和してACだが？
    - 累積和とっといて範囲外の最大から範囲外の最大を引けば範囲内の総和が求まるんじゃね的な
  - とか思って前回解いたやつみたらなるほどね いもすじゃないけどねこれ
   - kから始める、を考えず、0~nまでやるんだけどk未満は無視、は確かに。無駄だけどこっちのが考えるの楽だな

#### 038
C
- ACしたけど解説みたらああそんなアルゴリズムあったね...ってなった
- 単調増加しなくなるまで長さをとっておいて、しなくなったときの長さをLとすれば∑(L)個出るのでそれを足していく、最後に残ったLもちゃんと処理する、っていう方針でやった
- 言うまでもなく解説の尺取法使ったほうがスマートでクレバー
  - 計算量は変わらん せいぜい∑(L)のぶんがネックになる程度

#### 040 
全体的に脳死お断りな気がする（実力）

C
- 超典型DP
- よくよく考えれば`dfs(i, cost)`や`dfs(i, step)`なんかのメソッドは必要なく、単にDPの配列のみで良いことに気づく（2REして意味不明なったんで答えみたらわかった）
  - そもそも **蟻本曰く、引数にコストを含めるのは愚**なので`dfs(i, cost)`はダメ
#### 041
C
- kuso. 座圧的な発想はすぐに浮かんだ、まではいいんだけど
- その座圧の実装がどうやるか思い出せず、配列っしょwと思ってたわ
  - 辞書でした。死ぬべき
    - 解説みるとふつうにpairでもいけるので、べつに辞書にとらわれる必要はなくて、単にお前の頭がゴミだったってだけ pgr
- マジで何年やってんだ 脳味噌腐ってんじゃねぇのか
- さっきなんも見ずにpythonで実装したら一発だったんだけど、発想が座圧なのは浮かぶけど座圧の実装は忘れた。愚直にリストでやった
#### 042
C
- インクリメントするか...いや間に合わないか
  - 一文字ずつとってみるか...いや上下どちらからやっても繰り上がりがうまくできんな...
  - どうすっかな...激ムズだな...
  - 解説みる -> クソでした死にます
- さっき4ヶ月ぶりにやり直した。問題読んで場合分けめんどくさいなーとか思いつつ10分くらいtwitterに逃げてて、戻ってきてから「N<=100000だしインクリメントでいいんじゃね」となってやったら通りました
D
- dpマップを作ったところでnCrの計算ができず、ひとつずつ見ていく想定でやってたので間に合わないことに気づく。
  - -> 死亡
- 死亡したので解説を読む。ちっともわからん。
  - 1ググりして出てきた[これ](http://tatanaideyo.hatenablog.com/entry/2016/07/24/031338)を読んで（これは公式の解説とは別の解法だが）わかった気になったつもりになり、実装はせず
- ムズい なんだよフェルマーの少定理て nCrて これは数学です
#### 043
C
- 「minとmaxのmid（+1 if odd）したやつをターゲットにすればいいかな...」
  - なぜか負数があるがこの考えだと無意味なんだよな引掛けか？？
  - もちろんなんの根拠もないし考察なんてしてない、サンプルが通るだけ
- 解説みる -> マジでクソ。
- > この時-100から100 までの整数しか考える必要はない。(-100未満や100より大きくしても、各(ai-X)^2はX=-100や100の時と比べ大きくなるだけなので、無駄。)
- これの意味がわからんけど、要は
  - ai=100のときは100にしたら(x-y)^2=0になる、100より上だと増えていく
  - ai=-100のときは-100にしたら同じく0になる
  - っていうことだろう
- いずれにしろWAしたしクソ
- 4ヶ月ぶりに解いた。ひと目で(max-min)/2を目指せばいいやんと思いこんで以前書いたコードを見て驚愕した。全探索。。。制約をちゃんと読もう....
  - 精進問題....
D
- 初のなんも見ずに解いたD
  - 🎉
  - 考察もだいたいあってた
  

#### 044
C
- 「途中でぶった切る再帰で十分だろ」->「げぇっ最後のサンプル確かにこういう場合があるのか...確かに..」
- で解説みた
- まあふつうにdpだったんですが変数のもたせ方にまったく自信がなくてそのへんは解説見た
  - 三次元dpで50\*50\*2500ってのは直感なんだけど、そんなでかい数値ありえねぇだろってのもまた直感
  - ふつうに計算すれば間に合う感じでした
- メモ化再帰を組めるのは楽しい
- だがfuck 何時間かけてかいたんだこの程度に
#### 045
C
- 愚直解しか思いつかなかったのでやったが実装がハゲそう
  - 途中で耐えきれなくなって解説をみたら愚直解だったのでなんとか書ききった
  - つらい
- 合計値を出すメソッドよく書けたなこれ...
- いくつ入れるか+どこに入れるか、でnからc個とる組み合わせのやつをc++していったのだが、解答のやたらと短いやつをみると「+をいれるかいれずにつなげるか」のdfsっぽいのがあったのでぎゃふん
- pythonで解き直し。以前の回答は見てない
  - eval is evil
  - 愚直回しか思いつかない。再帰で入れるかどうか判断していく
  - Cのわりに簡単すぎる。200くらいでいいんじゃないか。再帰入門的な
#### 046
C
- shit one.
- 地道にインクリメントして当然のようにTLE
  - じゃあにぶたんで求めるか〜ってところで鬱になったので1秒で諦めたのだが、ggるとにぶたんでやってる人もいた（通るらしい）
- 解説をみたが1bitも理解できないのだが...?
  - 比になるのはいいとしてなんで *このようなxは~で計算できます*になるのだ
  - なんで計算できるかをしりたいのだが?
- 解説例の解説 わかった気になる [https://ameblo.jp/weibeicun/entry-12438868527.html](https://ameblo.jp/weibeicun/entry-12438868527.html)
D
- DPかなと思って実装したがN=20程度でも帰ってこず、死
- 答えみた
  - マジかよ考察力....
  - 相手も同じルールってのが抜けてたわ
  - これは太刀打ちできん考察問題のレベルを感じる
#### 047
C
- 頭からみていってシミュレーション的に変えていくのを思いついて、よさそうだというところで、実装の前に**以前かいたやつを見てしまい**、それは解説を読んだやつっぽかったんだけど,自分が思いついたやつよりも更に一歩考察を進めたものだった。。。。
  - 死
#### 048
C
- 前やったのを覚えていちゃった
#### 049
C
- 「ははーんこれは幅優先だな」 -> あぼーｎ
- 解説みる -> は？？？？？？？？？？？？？？（激怒）
- これはひどい
- 4ヶ月ぶりに解き直した
 - 解法覚えてた
 - なぜか意味不明なことに1WAして完全に意味不明なったけどな
#### 050
C
- はい
  - 履歴消えた？？？？？
- 最初から考察は出来ていたっぽいのだが現行atcoderのrubyのバージョンが時代錯誤すぎて1WA,仕方なく直したやつでTLEを喰らった
- ので、別の視点から書いた
- nから配列は一意に同定できるのでそれを出して比較
- 見てりゃわかるし難易度はミドリムシ程度
- fuck one damn it shit kill

#### 051
C
- 最短距離は(tx-sx)回x方向と(ty-sy)回y方向に動くやつで、1往復すると周囲2マス使えなくなる
- そこを避けて最短距離の外側をとおる
  - 位置関係が判明しているのでそのぶんR, L, U, Dを繰り返せばいい

#### 053
C
- damnit. 計算はだいぶ悩んで浮かんだ。ただし実装がクソ
- 死にたい
#### 054
C
- 超典型グラフDFSの超簡易なやつ
  - 特筆することはないが一番最初の練習にいいんじゃないの
#### 055
C
- 考察あってたんだけどなぜか実装でそれに従わないゴミ回答をしてしまい1WA...
- 問題自体はAレベルのさんすうだっただけにクソ
- 4ヶ月ぶりにぶりに解き直し
  - 方針は1秒だったけどなんかしらんけど場合分けをバグらせてハマった......退化....
#### 056
C
- 何回か挟んで考えた 
  - そのうち何度かはクソ
- 提出したやつはまとも
  - ただ、`10**9`ということで、最初にぜんぶとってからの累積和、というのは最初に取る段階でTEFなるのでダメ
- 以下かんがえたやつ
- A[n]からA[n-1]までの数は問題の性質からそれまでのA[i]を調べて任意の数を取って並び替えればどれかは達成できるやつになってる
  - なので適当に累積和っぽいこと(TLEなるのでメモリにはおけない)をやっていって更新してく感じ
  - わりと思いつかなかった 死
#### 057
C
- 一年前にgoで解いてたらしい
- 今回pyでやったんだけど、解けたんだけどgoの答えみたらクレバーだったしなかなかに時間かかったので負けです
 - goでやったやつ range sqrt(n)してiで割り切れる最もデカいのを保存しといて最後に商との桁を比較
 - pyでやったやつ 素数以外として、10^10なら最大で5桁までをみればいいのでふつうに全探索したあと↑
- 微妙に思考過程が違ってて面白い
#### 058
C
- 前回は4ヶ月ほど前にrubyで出したらしい。今回pythonで解いてから.rbのほうをみた。基本的な方針は同じで、実装が少しクレバーだった
  - 最初のやつを基準にしてそこに含まれているものだけを考える、とか
  - 今回はわざわざN個文のアルファペット辞書を用意して、N回回してからもう一度最小値を取るために回して、というのをしたが、最小値も都度更新できるので。
- 現時点でatcoderのpythonのバージョンが低いため辞書が順番を保持しておらず1WA。
#### 062
C
- n回くらいトライしててぜんぶ同じ戦法（3で割った商を越える最小のw\*iかh\*jを抜いたものを2で割った商を越える最小のw\*iかh\*jを導出）でやったんだけどいずれもクソ
  - 考えすらあってるのかわからんけど
- 答えみたらパターンで全探索だった
  - は？パターン？
  - abcで分けるとするとこうなるよねっていう図式 納得いかん
  - 解説読んだらとりあえず解けたけどこんなもん誰も浮かばんだろ
  - しかも*4パターンのうち2パターンはもう一方のh, wを入れ替えたもの*とか*できるだけ差が小さくなるってことで二分でいい*とか細かい気付きも要求される
  - 非常にダメ
  - 自尊心死んだ
  - こんなもんに数時間かけたのマジで鬱なる
  - キレたし泣いた
  - デカい声では？？？？？？？？？っつってたら近所のおじさんに怒られたのでマジで死にたい

#### 063
C
- 点数が大きいほうが嬉しいので、10の倍数にならないように低い点数を引く

#### 064
C
- いやこんなんふつう最大8色って思わない？問題文じゃなくて例題にしれっと「紫」「黒」とか書くの悪問でしょ
- あとなんかしらんけど`array[8]`にしてまだとってなかったら=1にして最後にsumする、ってやつだとなぜか2ケースでWAで、`bool[8, false]`してあったらtrueにして最後にtrueを数えるっていう、まったく同じロジックのやつだと通る。これはpythonとrubyで試したけど完全に謎。バグでは
#### 066
C
- 4ヶ月前もやってて通してたっぽい
 - Cの中でも最弱
- 似たような発想だが、今回は後ろから作っていっているのに対し、前回のは（なんかたぶん前からやるような）別のアプローチでやっている模様
  - なお前回やっていた記憶はまったくない。記憶に残らない程度の簡単な問題ということだろう

#### 068
C
- 何回かにわけてアタック
  - いずれもすぐ諦めてたけど
- さっきの試行で、a==1以外とb==N以外はみなくていいって気づいた
- ので、適当に実装
  - いうて1時間くらい？かけたんちゃう
  - 映画みたり酒飲みながらだけど
- 意外とうまくいってうれpのだが数回アタックしたのでダメ
- 三ヶ月ぶりに解いたらしい
  -うっっすらと記憶に無い
  - 三点で考える場合は中間地点の気持ちになる。今回は始点と終点が決まっているのでめっちゃ楽


#### 069
C
- 4の倍数と奇数だけに注目すればええやんけ〜
  - 無事死亡
- キレそうになりながらコーナーケースとダメケースを考察したら思いつくまで少し時間かかった
  - それはいいのだが実装までも無駄に時間を喰ったのがマジで気に入らない
- fuck
D
- 問題読んでないけど一行にして折り返せばいいよね
#### 070
B
- ついにBごとき問題でもWAをやらかした
  - マジで死ぬべきだと思う
  - こんなんを間違うやつが生きてても世界になんの役にも立たない
- は？？？？？？？？？？？？？？？？？？？？？
C
- 読んだらlcmを求めるってことくらいは理解できる
- なので全体のlcmを求める
  - 公式知らんかったのでggった
- アルゴリズムのコアの実装は合ってたけど渡す値と答えをミスってて1WA
- まあアルゴわかってただけでいいっしょ

#### 072
C
- scum.
- 最初最頻値+-1を足してて2WA.
  - マジでこれしかないだろと思ってた
- 諦めて解説読むとあばばばばばばばば
  - 一瞬で最頻値の反例が浮かんであばばばばばっばばばばばばばばｂ
  - こういう低いレベルの"気づき"がまったく出来ない、死にたい
- 4ヶ月ぶりに解いた
 - 最初N個の+-1だけみててWA(3 4 のとき 2 になるのを忘れていた)
 - ので、10^5ぶんを全探索した

D
- 単純な貪欲で頭からiとi+1をswapすればいいと思ってn-1回回したわけですがn回目でまさかのi==が発生するようで、これがわけわがわからん
  - は？？？？？？？？？？？？？？？？？？？？？？？
  - トイレいったら思いついた `4 3 2 1 5`の場合があるのでn番目まで見ないといけない。。。。

#### 073
C
- 辞書して偶数なら0、奇数なら1
- 1つずつみていくので偶数になった瞬間、すなわち「すでに存在している」場合は2になるのが当然なのでその場で消す
- したら結局は辞書のサイズになる
- はい
#### 075
B
- よくある2次元探索
- Bっぽくない気がするけどまあ所詮B、と思ってたらコーナーケースとその直し間違いで3WAくらいくらった
C
- グラフ問題
- 毎回特定の橋がないグラフを作ってDFSで全域木かどうか求める
  - です
- 3ヶ月ぶりに解いた
  - 前回解けてたみたいだけど「辺を取り除く」が生えなくて解説みたよね 退化
  - 隣接行列で辺が通ってるか管理する方法
  - 明らかに前回のやつの解法がスマートに感じる...

#### 077
C
- fxxk 2TLE 2RE
- 馬鹿だから「せやにぶたんや!」まで思いついたくせに、「nibutan(B, ai)してB[idx:]ぶんだけnibutan(C, bi)」するっていう無意味なことやってた
- 3数の大小関係の場合は真ん中の数字を基準にするとうまくいく関係性がある
#### 078
C
- Cの中では最弱
- テストケースの式の意味とかなんでそうなるのかは知らんけど、要はmの数だけ通るか通らないかの状態と組み合わせがあるわけで、最悪2^m回目で通るわけだ
  - というのを式に落として終了
#### 079
C
- Cの中では最弱
 - せいぜい2^3通りなので全部試せばいいだけ
 - eval is evil

#### 081
C
- 方針が立ってからの分岐が勝負
- 加工する必要があるときだけ**適度に**加工する
  - 条件を満たせばギリギリでいい
- 実装とコーナーケース潰しが下手糞すぎて10WA以上喰らった

#### 082
C
- Cの中では最弱
  - と思いきや誤読して3WA...(増やせるかと思ってた)
  - ふつうに数値と登場回数をハッシュなりでもって、多かったら差を、少かったら全部を取り除くカウント

#### 083
C
- 各要素に興味がないので、できるだけ長くするには初項が小さいと嬉しい（A1=x)。そして、できるだけ長くするには, Ai+1もできるだけ小さいと嬉しい (A2はA1の倍数なのでA2=A1+A1)。これを続ける
- かなり簡単な部類に入るC
  - 解説の数式はまったく読めない

#### 084
C
- shitone. 非常にダメ。死にたい。4hと結局解答。マジでダメ。脳が腐ってるうえに文盲みがある。
- 4ヶ月ぶりに挑んで解けたけど非常に頭が悪い
  - シミュレーションでいけると思ってやる
  - c + f * nを満たすnのうちcurrenttimeを超える最小のnを求めるのににぶたんを実装したのはどうやら悪手らしくて、条件から求まるらしいんだけど解説読んでもさっぱりわからん
D
- 10^5だし愚直にやってもいけんじゃねと思ってた時代もありました
  - 間に合わなくて1WA食らった
  - 真面目にやった。累積和+包除原理
#### 085
C
- オーダー見積もり && 整数 の典型
- 以前はrubyで出来てたっぽい -> 10ヶ月ぶりにチャレンジや
- -> ち〜ん
- **上限を2000に**,をしてなかった....2WA..
  - 「これやったことある知ってる〜こうやるんだろ〜」でゴミになった感じが強い
  - 反省しろ
D
- 問題文よむぼく -> あー？？？？？
  - 3分くらいで諦める
- 解説文よむぼく -> は？？？うせやろ・・！！！！！！！！！！！！！
  - Cにしろや
- 4ヶ月ぶりに解いた模様 うっすらと解法を覚えていた感じがする
  - ai<=biなので基本的にbiが強い。最強のaiより弱いbiは使う必要がない
  - 順番は関係ないので選びぬかれたbiを強いほうか使っていって、倒せなかったら最強のaiをHがなくなるまで使う

#### 087
C
- 累積和
 - じゃなくてもNがちいさいので全探索でもいい なんでもいい

#### 088
D
- 懐かしのほぼ典型迷路幅探索
  - 最短経路以外ぜんぶ壁で埋めればいい
  - ゴールできない場合を加味忘れて1WA

#### 089
C
- 考察10秒 -> 組み合わせ出せればいいんやろ -> 実装半日
  - 結局なぜかTLE出てダメで、解説みたらふつうに方針あってたのでキレた
- クソ
#### 090
C
- あれ?過去にほぼ同じの類題やったような
- そのマスを訪れた回数ぶん裏表裏を繰り返すので奇数回訪れたら裏
- n>=3 m>=3のとき奇数回訪れるのは外周以外の、周囲すべてをマスで囲まれた部分のみ
- 余裕

- きりみんちゃんから来ました
  - PHPで解いた
  - サンプル3を手元で適当に試したら答えになったので演繹した
    - `abs(a*b-(a*2+b*2)+4)`

#### 093
C
- 小さい方2つと最大値の差の偶奇で分岐
  - なぜか過去に3WAしてるらしい コード読んだけど読めない

#### 094
C
- N小さいし都度ソートしてもええやる
  - ダメでした
- 解説がなにをいってんのかわからんが、どうせ1ずらしたところで中央値なんて真ん中か真ん中の次（前）の二択なのでそれをとっておいて配列から順番に取り出したやつと比較する感じらしい
- なんで比較してうまくいくかってのはなんかよくわかってないけどノリで書いた
- クソ
#### 097
C
- 解説見る -> わからん
- ggって解説記事見る -> なるほど....
- ロジックは単純なんだけど全探索をfor二重でやるのすら思いつかない程度の`permutation`クズ
- 腑に落ちないってことはなく、まあそうだよね感があってあんまりキレはない🤬 
#### 098
C
- ヒント見てしまった
#### 099
C
- 「N以下の6^pと9^pなんてたかがしれてるんだしそれでgreedyすりゃいいだけじゃね?」->「私は考察のない貪欲をしました」
  - 実際はgreedyだと都合が悪いケースがある。14とか110とか
- dfsを試みるも当然のように時間がダメ
- メモ化再帰しようとするも、1と6と9で[N][~10][~10]では？と無能を呈してしまい無理
- 解説をみるも残念ながら理解できるレベルにあらず、これはどこの言語
- ggったらこれは難問らしく、取り上げたqiita記事まであった
- それを見てメモ化した。dpわからん

#### 100
C
- 考察してないんだけど眺めてたら偶数のこころが生えた

#### 102
C
- 過去に数回、延べ十時間以上使ってる気がするけど解けない（まだ解けてない）

#### 101
- 1で埋めればいいことは思いつく
- 最初「1の両端からk-1ぶん伸ばせばええやんけ」ロジックでやったらWA
  - そりゃそうだ、`2 1 3`で`k=3`のときこれだと2だが、真ん中からやれば1でできる
- 考え方を変えて、1のインデックスとは無関係に頭から出発し初手はk、残りはk-1ずつ伸ばしていけばすべて埋めれると気づく
  - Nが小さいので可能
- 通ってから解説をみたがさっぱりわからん なにこれ
#### 103
C
- 個人的に最速で解けたC
  - うれC
- 余りは割る数以上にはならないので-1したものの総和
- 雑すぎる考察だけどまあそんなもんだ
- 三ヶ月ぶりに解いた
  - 解けたんだけど愚直にlcmを使ってて、MLEなるかと思ったら通ったんだけど、↑の三ヶ月前の実装を見て驚愕した
  - よく当時こんなん生えたな わからんぞ
#### 106
C
- ろくな考察もせずに適当に書いて1waした挙げ句解説をみたのに更に1waを上乗せしたので吊るべき
  - わざわざ正答数が多い簡単な問題を選んだのになんだこの体たらくは お前は生きてる価値があるのか
  - 死
- shitshitshitshitshitshitsthimatherrrrrrrrrfuuuuuuuckkkkkkkkerrreeeeeeeeeeee
- 3ヶ月前にやったやつのやり直し Difficultyの低いやつ選んだのに
- 見たこと有るって言ってたのに無駄に時間かかった 混乱する
  - しかも無駄に2WA 死
#### 109
C
- gcd使う方針はあってたんだけどなぜか使い所がおかしくて
- xiとxi+1の差でgcdを使い
- 1からその差（最大公約数）までの約数のうちで
- Xから最も近いところ（にぶたんで求めた）にいける最も大きい数を求める
- という迂遠な方法でやった gcdの更新をミスって3WA
- すべての提出で一番最初のREが取れない、これはバグでは
- マジで鬱になった
#### 111
C
- 舐めてかかったらどんどん深みにハマった
- のべ半日以上くらいダラダラとやってた気がする
- 「手続きはすぐ思いつくけど実装がまったくできない」タイプ
- fuck
- なんでこうスマートに解けないのか
  - 先天的に脳細胞が欠乏しているとしか思えない、鬱になる
- しかも解説よんでやってもWAなる
  - マジで鬱が悪化する
#### 113
C
- 見た瞬間座圧的なインデックス入れ替えテクでいけるとわかるんだけど、
  - 「座圧ねーはいはい どうすんだっけ」っていう程度の雑魚認識なので調べてへーってなりながら実装したので死にたくなる時間がかかった
  - 自戒
- 0WA
  - 提出してから解説を見に行ったが見ても微塵もわからないタイプの解説なのでふつうにググったほうがいいかもしれない
    - 方針は合ってたのでべつにググって別解とか探してないけどな
- chokudaiがtwitterで今日の一問みたいな感じで挙げてたのでやった。問題自体忘れてたので丁度いい
  - 最初復元用に配列で入力をセーブしとくのが必要かと思ったが入力含めた三要素をとっといてそれぞれソートすればいいってのに気づく
  - 2019/08/23現在まだatcoderの言語アプデがきてないのでpython3の辞書は順序が保存されない点に注意してソートして最初なんか間違えて1WA
  
#### 114
C
- 「うまい具合に3, 5, 7でスイッチする方法わからんな〜」
- 解説みたら**3or5or7が含まれてるやつ全列挙してあとで全て含んでるか判断**というマジかよってなる手を使うとのこと...oh...
- 実際それでもせいぜい29523個しかないのでソートして探してまでやっても余裕で間に合うという...してやられたわ
#### 118
C
- 観た感じGCDの匂いがするがぜんぜん考察も証明もできず
- まさかなハハッとか思いながらGCD書いたら通った
- 解説読んでも理解できん
- というかそもそもGCDが証明できん
#### 119
C
- もうわけわかんねぇからググったわ
  - 難しい部類に入るらしい
- Nが小さいので実は全探索と気づける
- A,B,C,不採用の4つの状態をそれぞれのやつにもたせて、答えはA,B,Cとの差の絶対値でどれだけインクリメント/デクリメントすればいいかわかる
  - そんで最小値を更新していく
- ってとこに気づいたところで実装も悩む 再帰書けないマンになって死

#### 120
C
- Streakのために簡単なやつを解いた
  - 最終形態は0000か1111かなのでmin(one, zero)*2

#### 121
C
- できるだけ安く済ませたいのでAiで貪欲です おわり
  - なーにが終わりじゃ 3WAくらいした
  - テストでの`print`消しわすれ2件, **Aiが複数回登場する** を見抜けなくて1WA
  - Streakのために簡単なやつを選んだはずなのに死

#### 122
A
- はい

B
- はい。Nが小さいので全探索

C
- Nが大きいので累積和作っといてクエリはO(1)にする
- 3ヶ月ぶりの挑戦。
 - Atcoder ProblemsのProblem ListのDifficultyで低かったので。
 - うっすらと見た覚えがあったのでなんとなく累積和した。rbのバージョンがクソでよくわからんエラー吐きつつもチューニングしてAC

#### 123
C
- ボトルネック

#### 124
C
- 2ヶ月前にやったばかりだったわ
  - Streakが途絶えそうだったので慌ててDifficultyの低いやつをやるという。。
  - そっちのコードはなかなかクレバーだった。最初の文字をキーにして探索するやつ
  - 今回のはインデックスと`b`or`w`の4通りを毎回試す感じで解いた
- 最終状態が一意に定まる系の問題は、実際にやってみるといいかもしれない

#### 125
C
- ~負数の数は0か1にできる + 場所は移動できる~
  - ↑ たぶん問題違う
- 100回くらい挑戦したけどそのたびわからなくて解答見て理解した気になって1byteも書かずに忘れるのを繰り返してた
  - gcd(arr) = gcd(a[0], gcd(a[1], gcd(a[2], gcd(a[3], gcd(a[4], ...)))))
  - と、変えるaの（変えた先の）値はなんでもいい = 無視していい、ということから考える
- などと書いたくせに「了解！」と思って実装したらWAだったのでマジでキレてる
- めっっっっっっっちゃ嫌いな問題 苦手じゃなくて嫌い マジでヤだ

D
- 任意の2つの符号を変えられるので、負の数が偶数か奇数かで、最終的に残る負の数は0個か1個にできる。1個の場合は最も小さい数を選べばいい

#### 128
C
- 初見でやるのはちょい難しそう
- N, M<=10なので全探索の気持ちが生える
  - -> N個のスイッチについて0,1のすべての状態を想定し、
  - それぞれについてみたとき、各電球が条件を満たしているか都度判断する
- 2^Nのバイナリ表現をうまいこと（あとでMのあり得るべき状態と比較して判定する時に楽になるように）配列を組んでまあなんか好きな方法で作成する

#### 129
3完+Dの考察合格。全体的にやさしいというか、アルゴリズムはごく初級レベルでいける

C
- 一次元DP．ABC040でやったばかりだったのでまだ記憶にあった
  - いうて本番では頭がバグって一旦置いた
D
- なんとなく考察は出来たが実装にいたらず。終了後10分ほどで提出したものはTLE
  - コード自体に改善の余地はあるんだけど、そもそもpython(pypy)で解くのつらい？
  - にゃーん..
#### 130
3完 C解けず 初めてコンテスト中にD解けた
C
- 本番で死ぬほど誤読してて、「最小値」かと思ってたので死んだ
 - ちゃんと日本語を読めば解ける最易問題
D
- ふつうに尺取法をやるだけっぽかったけど実装忘れたのでggって出てきたけんちょんさんのqiitaを丸パクリしたりした
  - Cに時間をかけすぎていたせいで提出が遅れてしまった...（本番）

#### 131
死のfloor(2.5)完
C
- 本番中は掛ける数をにぶたんで求めて、これは今でも謎だが最後のケースだけ失敗してた
  - 死
  - 解説一瞬みて生えて死にたくなりながら書いたがサンプルが通らず死のうかと思ってた。
  - B-Aじゃなくて B-(A-1) Aは含むので
- 久しぶりにやった 包除原理は覚えてた
  - **B-Aじゃなくて B-(A-1) Aは含むので** これできなくて死んだ
D
- 締切が近い順にやる（締め切り時間が同じならその中でかかる時間の順番は関係ない）

#### 132
初4完だけどやっぱ相当易化してるので...
C
- Cの中では最弱
  - ソートして真ん中ふたつを比較して終了
D
- 順当に数学的に解く。nCrで球を置く場所を取るのと、二項定理で球の選び方をとって掛け合わせる

#### 140
C
- nとn+1を見るので後ろからみていく、という発想が生える
- `b[i] = min(a[i], a[i+i])`だと思ったら`b[i] >= min(a[i], a[i+i])`だということに気づく
- つまり毎回iだけでなくてi+1も更新する、といけるのでは?
  - -> いけました

#### 142
C
- 新レートのCで最弱
  - サンプルをみれば自明 終了
  
### ARC
#### 005
A
- まだABCのC==ARCのAじゃなかった時代？
- 考察1秒 実装10秒
- アルゴリズム以前なので誰でもいけますが0点相当だと思いましょう
 - 言語によるけど3分岐するよりかは入力を変形したほうがいいよね
 #### 007
 A
- まだABCのC==ARCのAじゃなかった時代？
- 例によってアホほど初心者っつーか入門者向けの難易度0
- 回答数を稼ぐためにこんなん解くの情けなくなってきた
#### 010
A
- はい
- 書いてあるとおりにやればいいです
#### 040
A
- シミュ
- 書いてあるとおりにやればいいです
- とくにアルゴリズム的な知識は不要で、配列ができればいいです
#### 042
#### 049
A
- はい
#### 057
A
- どうすっかな〜〜って唸ってたんだけどよくよくサンプルみたらすげぇちっさい
  - よくよく考えたらk=2で倍々マンだし最も小さいa, k = 1, 1でも40回はやれば終わる
  - k=0のときはインクリメントになるので引き算
#### 079
A
- 中間を訪れたかどうかもっておいて判定
  - 自分は配列1つだけにしたが、解説みるとtoとfromのぶん2つもっておけばもっと楽だったらしい
#### 080
C
- ARC-Cの中では最弱
  - 奇数の隣は必ず4の倍数
  - `1 4 1`はOKだが`1 4 1 2`がアウトなことに注意して4の倍数と奇数の数を数える
#### 091
A
- 奇数回裏返れば裏になってるので偶数回裏返る場所をはじき出す 

#### 093
A
- 差分取ればいいんだけどその利用の仕方があんまりうまく浮かばずハマった
 - 解説pdfは読めないのでqiitaで適当な記事を探して読んだらわかったけどかんたんすぎてアになった

### AGC
#### 005
A
- AGC Aの中では最弱
  - 今だと100点くらいの問題
  - SはストックのS ストックが続く限りTを消せる

A
- AGCの中では最弱と言おうとしたが最初「ソートした真ん中1/3」だと思いこんで自信満々で出してアウト
  - ソートして「上位から順に1位２位」「下位から適当に3位」で1セット*nが正解
#### 014
A
- シミュだなと気づくのおそすぎて60分くらい溶かした
- all sane odd の場合のコーナーケースが取れず30分くらい溶かした
- 死にたい

#### 015
A
- AGC Aの中では最弱
  - 4WA...
  - 最小値\*n-2~最大値\*n-2で1ずつインクリメントしたものが網羅できる
  - n > 1,  a < bが条件になってないという小賢しい罠
B
- AGC Bの中では最弱
- 必ず1回か2回で行ける
- 今より左と右でどっちかがそれぞれ1回、2回で行ける
#### 019
A
- こういう問題苦手
- 単純に2L基準の最小値、奇数Lなら更に1L基準でやったやつの最小値を加える

#### 020
A
- Streak用にDifficultyの低いやつをテキトーに選んだ
  - いずれの操作によっても初期位置から変わる互いの距離は2で割ってなるか1なるかどっちか
  - 仕方なく負ける瞬間を考えると、相手に踏まれる場合になる。これには相手が横に立っている必要がある
  - なので、先に横に立たれたら負け
#### 021
A
- 8か9で埋めればいいと思ったけど9だけでいい
- 996と699の結果は変わらないので先頭だけ-1して残りは9でいい
- ただし199とか、オリジナルが最大の場合もあるのでmaxを取る
  - これを忘れて2WAした
  
#### 029
A
- 最終形態から考えるとWの移動距離になる

### 外部コンテンスト
#### COLOCON -Colopl programming contest 2018- Final（オープンコンテスト）

A
- 前後にAが含まれない場合とAだけの場合とそれ以外の場合で場合分けしたんだけどこれはクレバーではない（TLE, WAを経てのAC）
- 解説が死ぬほど分かりにくい。他の提出を参照するもなんかよくわからん
  - 境界の数？？？？？？で判断？？？？？？？？？？
- Aしかない場合の`(x*(x+1)//n`ググった 数列の和か
- 累積和を使ったがコレ以外の方法が思いつかん


=======
## atcoder
### ABC
#### 004
C
- 30回でもとの配列に戻るってのは見てたら2秒で浮かぶのでそれで丸めた範囲だけやる
- はい
 - 独自に余りをだしたらふつうにバグを埋め込んでしまったが問題文通り`mod 5`しましょう
  - `(i-1)%5`とかしててループしてしまってあぼーんなった(わかりづらい)

#### 005
C
- 4回目の挑戦で足掛け半年くらいらしいが解けた
  - 今までどんなやり方をしてたかは見てない
  - 使えるやつから使ってみて、使ったやつ以前のやつは省いた貪欲で解いた

#### 006
C
- 解けず
  - いつものようにa+b+c=n, 2a+3b+4c=mとやってもダメ（TLEと、なぜかWAが生えてきた）
  - 解説は読めない
  - 他の回答をみるとO(1)でもいけるらしいがぜんぜん読めない

#### 007
C
- ただの超典型BFSなんだけど謎のバグで無駄に時間かかったし結局バグは回避しただけでまっっったく納得がいかない
- キレそう
- 結局はただの超典型BFS
D
- 超典型のdigit DPらしい
  - なにそれ
  - 調べた
- digit DPとかいうやつに初めてあたった。こういうことか
  - 理解するのに半日かかった
  - いうてどうせ典型しか解けないので理解できてないってワケ

#### 010
C
- はい

#### 011
C
- 0からスタートして3,ダメなら2,ダメなら1を加えてく
  - 加えるときにnを越えないという条件
  - ぜんぶダメならもうお前はダメだ
- カウントの上限と最初からn==ngの場合をちゃんと考えておく
- dp解があるらしいがまったくわからん

#### 012
C
- あんま解いても意味ないC
- 数学でもアルゴリズムでもデータ構造でもない さんすう

#### 014
C
- いもす法入門
- どっかでみたな〜〜っつって公式みたら問題例そのまんまっぽい感じのやつ
- 完全に忘れていたので一読した
- いい加減そらで書けるくらいになりたい..
  - 0WAだったけど自戒を込めて
- 3ヶ月ぶりに解いた。前回のは覚えてない
  - 典型imosが浮かんだ
  - n,a,b=1,0,0のコーナーケースでWAなるコードを書いてしまった...
#### 015
C
- nもkも小さいのでそのままDFSして見つけたら終了っていう脳筋
- DFSとxorの問題
  - xorは直近やった121Dで出てきたばかりだけどどうせ小さいのでなんも効率化せずに回した
- クソ寝ぼけてて頭が働かなかったのでこの程度の低レベルな再帰ごときに時間をかけてしまった
  - dfsの再帰のこういう形（ひとつだけの解を出すため呼出し元にreturnしたりはしない）っていうのは好きじゃない
- shit one.
#### 016
C
- 解説が一切わからん。は？最短経路？
- 適当に二次元リストで友達のIDを保存していくとなんかどっかで重複するっぽいんだけどわけがわからず、それもリスト取って確認したら重複してるやつ除けばいいっぽいのでそうしたんだけど原因が一切わからん
#### 019
C
- また問題文を読んでなかったやつ
  - 与えられる配列から[i]*2 = [j]になるやつを探すのかと思った
- domn
#### 026
C
- いや再帰するだけなんだけど。rubyがクソなせいでreturnの部分のクソ簡単なバグが取れずに数時間溶かしたのでキレ気味に追加
#### 27
B
- Dificultyが800越えのABC-Bって珍しいなと思って解いた
- 最初シミュレーションのつもりでやってたけど、途中で天啓
  - 「多くても少なくても橋かけなきゃ駄目じゃん」
  - 「今みてる時点のidx * dividerがいまの累積和じゃなかったら橋かけなきゃ駄目じゃん」
- でなんとなくやってAC うれC
  - Dificulty的には易しめだけど気づきの問題として入門的で嬉しい

#### 029
D
- 「桁dpの問題」みたいなリンクからやった
- 解法ヒントがあればまあその程度って感じ
  - 1ってのがミソで、単に数えたものの総数なので最大でも桁ぶんしか無い
  - ので、メモリに乗る程度のメモ用テーブルが組める
#### 032
C
- 文字読めないから順序うんぬんを飛ばして読んでて、「ソートして頭からやればいい」と思い込んでた
  - キレて解説みたらは〜ん？となった
- 尺取法とかいうのを解説に沿って実装したが3ケースでTLEになる クソ
  - 積をいちいち計算してたらダメらしく、計算結果をもつ変数をもたせると3WAなる クソ
- 結局わけがわからんが、r == lとなったときにr+=1して結果を1にするみたいなことをするといけるらしいがまるでわけがわかりませんね、クソ
#### 034
C
- 数時間かけたが一切理解できなかったので諦め問題
- 俺たちは何回「こんなんDPでいけるやろ典型」とか言って挑戦して玉砕してるのか？
  - ついさっきやった（2019/03/05 23:36 戒め）
- フェルマーの小定理？？？？？？？？？なにそれ
  - ggって唯一納得のいく説明[https://www.surweb.jp/sur/faq/fermat1.html](https://www.surweb.jp/sur/faq/fermat1.html)
- 逆元？？？？？？？？？？？？？？？？？？なにそれ
  - なんで逆元を求めればいいのかさっぱりわからん無理。階乗の話じゃないの？
- 繰り返し二乗法?????????????????????????????????????なにそれ


#### 035
C
- fuck. いもす法とか知らない。なんか頻出いうわりに初めて知った。使い方も実装も（この問題では）簡単だったけどたぶんいつもの典型以外解けないやつだろ
- あと解説文に騙されたが冷静に考えればi番目をi+1に加算ってのは嘘でiにi-1を加算だろうが

#### 037
C
- ↑C35ひと月前にいもすとか知らないと書いてたな、まだ1次元だけだが相当出てくるぞ > 1月前の俺
- 変形いもすであぶれたぶんを引いていく感じ
- 実装はなんか泥臭いというかもっと工夫できたんじゃないかな

- 4ヶ月ぶりに解き直した
  - いもす？普通に累積和してACだが？
    - 累積和とっといて範囲外の最大から範囲外の最大を引けば範囲内の総和が求まるんじゃね的な
  - とか思って前回解いたやつみたらなるほどね いもすじゃないけどねこれ
   - kから始める、を考えず、0~nまでやるんだけどk未満は無視、は確かに。無駄だけどこっちのが考えるの楽だな

#### 038
C
- ACしたけど解説みたらああそんなアルゴリズムあったね...ってなった
- 単調増加しなくなるまで長さをとっておいて、しなくなったときの長さをLとすれば∑(L)個出るのでそれを足していく、最後に残ったLもちゃんと処理する、っていう方針でやった
- 言うまでもなく解説の尺取法使ったほうがスマートでクレバー
  - 計算量は変わらん せいぜい∑(L)のぶんがネックになる程度

#### 040 
全体的に脳死お断りな気がする（実力）

C
- 超典型DP
- よくよく考えれば`dfs(i, cost)`や`dfs(i, step)`なんかのメソッドは必要なく、単にDPの配列のみで良いことに気づく（2REして意味不明なったんで答えみたらわかった）
  - そもそも **蟻本曰く、引数にコストを含めるのは愚**なので`dfs(i, cost)`はダメ
#### 041
C
- kuso. 座圧的な発想はすぐに浮かんだ、まではいいんだけど
- その座圧の実装がどうやるか思い出せず、配列っしょwと思ってたわ
  - 辞書でした。死ぬべき
    - 解説みるとふつうにpairでもいけるので、べつに辞書にとらわれる必要はなくて、単にお前の頭がゴミだったってだけ pgr
- マジで何年やってんだ 脳味噌腐ってんじゃねぇのか
- さっきなんも見ずにpythonで実装したら一発だったんだけど、発想が座圧なのは浮かぶけど座圧の実装は忘れた。愚直にリストでやった
#### 042
C
- インクリメントするか...いや間に合わないか
  - 一文字ずつとってみるか...いや上下どちらからやっても繰り上がりがうまくできんな...
  - どうすっかな...激ムズだな...
  - 解説みる -> クソでした死にます
- さっき4ヶ月ぶりにやり直した。問題読んで場合分けめんどくさいなーとか思いつつ10分くらいtwitterに逃げてて、戻ってきてから「N<=100000だしインクリメントでいいんじゃね」となってやったら通りました
D
- dpマップを作ったところでnCrの計算ができず、ひとつずつ見ていく想定でやってたので間に合わないことに気づく。
  - -> 死亡
- 死亡したので解説を読む。ちっともわからん。
  - 1ググりして出てきた[これ](http://tatanaideyo.hatenablog.com/entry/2016/07/24/031338)を読んで（これは公式の解説とは別の解法だが）わかった気になったつもりになり、実装はせず
- ムズい なんだよフェルマーの少定理て nCrて これは数学です
#### 043
C
- 「minとmaxのmid（+1 if odd）したやつをターゲットにすればいいかな...」
  - なぜか負数があるがこの考えだと無意味なんだよな引掛けか？？
  - もちろんなんの根拠もないし考察なんてしてない、サンプルが通るだけ
- 解説みる -> マジでクソ。
- > この時-100から100 までの整数しか考える必要はない。(-100未満や100より大きくしても、各(ai-X)^2はX=-100や100の時と比べ大きくなるだけなので、無駄。)
- これの意味がわからんけど、要は
  - ai=100のときは100にしたら(x-y)^2=0になる、100より上だと増えていく
  - ai=-100のときは-100にしたら同じく0になる
  - っていうことだろう
- いずれにしろWAしたしクソ
- 4ヶ月ぶりに解いた。ひと目で(max-min)/2を目指せばいいやんと思いこんで以前書いたコードを見て驚愕した。全探索。。。制約をちゃんと読もう....
  - 精進問題....
D
- 初のなんも見ずに解いたD
  - 🎉
  - 考察もだいたいあってた
  

#### 044
C
- 「途中でぶった切る再帰で十分だろ」->「げぇっ最後のサンプル確かにこういう場合があるのか...確かに..」
- で解説みた
- まあふつうにdpだったんですが変数のもたせ方にまったく自信がなくてそのへんは解説見た
  - 三次元dpで50\*50\*2500ってのは直感なんだけど、そんなでかい数値ありえねぇだろってのもまた直感
  - ふつうに計算すれば間に合う感じでした
- メモ化再帰を組めるのは楽しい
- だがfuck 何時間かけてかいたんだこの程度に
#### 045
C
- 愚直解しか思いつかなかったのでやったが実装がハゲそう
  - 途中で耐えきれなくなって解説をみたら愚直解だったのでなんとか書ききった
  - つらい
- 合計値を出すメソッドよく書けたなこれ...
- いくつ入れるか+どこに入れるか、でnからc個とる組み合わせのやつをc++していったのだが、解答のやたらと短いやつをみると「+をいれるかいれずにつなげるか」のdfsっぽいのがあったのでぎゃふん
- pythonで解き直し。以前の回答は見てない
  - eval is evil
  - 愚直回しか思いつかない。再帰で入れるかどうか判断していく
  - Cのわりに簡単すぎる。200くらいでいいんじゃないか。再帰入門的な
#### 046
C
- shit one.
- 地道にインクリメントして当然のようにTLE
  - じゃあにぶたんで求めるか〜ってところで鬱になったので1秒で諦めたのだが、ggるとにぶたんでやってる人もいた（通るらしい）
- 解説をみたが1bitも理解できないのだが...?
  - 比になるのはいいとしてなんで *このようなxは~で計算できます*になるのだ
  - なんで計算できるかをしりたいのだが?
- 解説例の解説 わかった気になる [https://ameblo.jp/weibeicun/entry-12438868527.html](https://ameblo.jp/weibeicun/entry-12438868527.html)
D
- DPかなと思って実装したがN=20程度でも帰ってこず、死
- 答えみた
  - マジかよ考察力....
  - 相手も同じルールってのが抜けてたわ
  - これは太刀打ちできん考察問題のレベルを感じる
#### 047
C
- 頭からみていってシミュレーション的に変えていくのを思いついて、よさそうだというところで、実装の前に**以前かいたやつを見てしまい**、それは解説を読んだやつっぽかったんだけど,自分が思いついたやつよりも更に一歩考察を進めたものだった。。。。
  - 死
#### 048
C
- 前やったのを覚えていちゃった
- 前やったのを忘れてた
  - こういうのは頭からみたときに自分と自分よりひとつ下のやつだけを見るので、減らす数を最小にするのならばひとつ前はどうせ次のときは使われないので、自分を優先にして引いたほうがいい
#### 049
C
- 「ははーんこれは幅優先だな」 -> あぼーｎ
- 解説みる -> は？？？？？？？？？？？？？？（激怒）
- これはひどい
- 4ヶ月ぶりに解き直した
 - 解法覚えてた
 - なぜか意味不明なことに1WAして完全に意味不明なったけどな
#### 050
C
- はい
  - 履歴消えた？？？？？
- 最初から考察は出来ていたっぽいのだが現行atcoderのrubyのバージョンが時代錯誤すぎて1WA,仕方なく直したやつでTLEを喰らった
- ので、別の視点から書いた
- nから配列は一意に同定できるのでそれを出して比較
- 見てりゃわかるし難易度はミドリムシ程度
- fuck one damn it shit kill

#### 051
C
- 最短距離は(tx-sx)回x方向と(ty-sy)回y方向に動くやつで、1往復すると周囲2マス使えなくなる
- そこを避けて最短距離の外側をとおる
  - 位置関係が判明しているのでそのぶんR, L, U, Dを繰り返せばいい

#### 052
D
- きりみんちゃんの放送で500の中では最弱ときいて
 - マジで最弱だった dpですらない
- 毎回次のステップと今のステップの差だけを考えて更新していくだけ 終了

#### 053
C
- damnit. 計算はだいぶ悩んで浮かんだ。ただし実装がクソ
- 死にたい
#### 054
C
- 超典型グラフDFSの超簡易なやつ
  - 特筆することはないが一番最初の練習にいいんじゃないの
#### 055
C
- 考察あってたんだけどなぜか実装でそれに従わないゴミ回答をしてしまい1WA...
- 問題自体はAレベルのさんすうだっただけにクソ
- 4ヶ月ぶりにぶりに解き直し
  - 方針は1秒だったけどなんかしらんけど場合分けをバグらせてハマった......退化....
#### 056
C
- 何回か挟んで考えた 
  - そのうち何度かはクソ
- 提出したやつはまとも
  - ただ、`10**9`ということで、最初にぜんぶとってからの累積和、というのは最初に取る段階でTEFなるのでダメ
- 以下かんがえたやつ
- A[n]からA[n-1]までの数は問題の性質からそれまでのA[i]を調べて任意の数を取って並び替えればどれかは達成できるやつになってる
  - なので適当に累積和っぽいこと(TLEなるのでメモリにはおけない)をやっていって更新してく感じ
  - わりと思いつかなかった 死
#### 057
C
- 一年前にgoで解いてたらしい
- 今回pyでやったんだけど、解けたんだけどgoの答えみたらクレバーだったしなかなかに時間かかったので負けです
 - goでやったやつ range sqrt(n)してiで割り切れる最もデカいのを保存しといて最後に商との桁を比較
 - pyでやったやつ 素数以外として、10^10なら最大で5桁までをみればいいのでふつうに全探索したあと↑
- 微妙に思考過程が違ってて面白い
#### 058
C
- 前回は4ヶ月ほど前にrubyで出したらしい。今回pythonで解いてから.rbのほうをみた。基本的な方針は同じで、実装が少しクレバーだった
  - 最初のやつを基準にしてそこに含まれているものだけを考える、とか
  - 今回はわざわざN個文のアルファペット辞書を用意して、N回回してからもう一度最小値を取るために回して、というのをしたが、最小値も都度更新できるので。
- 現時点でatcoderのpythonのバージョンが低いため辞書が順番を保持しておらず1WA。
- 三ヶ月ぶりにやったらなんかわかんなくて↑の「最初のやつを基準にして」最小値を更新、をカンニングしてしまった
  - 衰退
  - 死にたい
#### 062
C
- n回くらいトライしててぜんぶ同じ戦法（3で割った商を越える最小のw\*iかh\*jを抜いたものを2で割った商を越える最小のw\*iかh\*jを導出）でやったんだけどいずれもクソ
  - 考えすらあってるのかわからんけど
- 答えみたらパターンで全探索だった
  - は？パターン？
  - abcで分けるとするとこうなるよねっていう図式 納得いかん
  - 解説読んだらとりあえず解けたけどこんなもん誰も浮かばんだろ
  - しかも*4パターンのうち2パターンはもう一方のh, wを入れ替えたもの*とか*できるだけ差が小さくなるってことで二分でいい*とか細かい気付きも要求される
  - 非常にダメ
  - 自尊心死んだ
  - こんなもんに数時間かけたのマジで鬱なる
  - キレたし泣いた
  - デカい声では？？？？？？？？？っつってたら近所のおじさんに怒られたのでマジで死にたい

#### 063
C
- 点数が大きいほうが嬉しいので、10の倍数にならないように低い点数を引く

#### 064
C
- いやこんなんふつう最大8色って思わない？問題文じゃなくて例題にしれっと「紫」「黒」とか書くの悪問でしょ
- あとなんかしらんけど`array[8]`にしてまだとってなかったら=1にして最後にsumする、ってやつだとなぜか2ケースでWAで、`bool[8, false]`してあったらtrueにして最後にtrueを数えるっていう、まったく同じロジックのやつだと通る。これはpythonとrubyで試したけど完全に謎。バグでは
#### 066
C
- 4ヶ月前もやってて通してたっぽい
 - Cの中でも最弱
- 似たような発想だが、今回は後ろから作っていっているのに対し、前回のは（なんかたぶん前からやるような）別のアプローチでやっている模様
  - なお前回やっていた記憶はまったくない。記憶に残らない程度の簡単な問題ということだろう

#### 67
C
- 累積和の、なんか `y-x`するやつの典型（名前失念。なんとかの定理？）
- まあそれだけなんだけど、知ってないと解けない典型
- ちなみに制約`1枚以上のカードを取る`を読み飛ばしていたよ

#### 068
C
- 何回かにわけてアタック
  - いずれもすぐ諦めてたけど
- さっきの試行で、a==1以外とb==N以外はみなくていいって気づいた
- ので、適当に実装
  - いうて1時間くらい？かけたんちゃう
  - 映画みたり酒飲みながらだけど
- 意外とうまくいってうれpのだが数回アタックしたのでダメ
- 三ヶ月ぶりに解いたらしい
  -うっっすらと記憶に無い
  - 三点で考える場合は中間地点の気持ちになる。今回は始点と終点が決まっているのでめっちゃ楽


#### 069
C
- 4の倍数と奇数だけに注目すればええやんけ〜
  - 無事死亡
- キレそうになりながらコーナーケースとダメケースを考察したら思いつくまで少し時間かかった
  - それはいいのだが実装までも無駄に時間を喰ったのがマジで気に入らない
- fuck
#### 070
B
- ついにBごとき問題でもWAをやらかした
  - マジで死ぬべきだと思う
  - こんなんを間違うやつが生きてても世界になんの役にも立たない
- は？？？？？？？？？？？？？？？？？？？？？
C
- 読んだらlcmを求めるってことくらいは理解できる
- なので全体のlcmを求める
  - 公式知らんかったのでggった
- アルゴリズムのコアの実装は合ってたけど渡す値と答えをミスってて1WA
- まあアルゴわかってただけでいいっしょ

#### 072
C
- scum.
- 最初最頻値+-1を足してて2WA.
  - マジでこれしかないだろと思ってた
- 諦めて解説読むとあばばばばばばばば
  - 一瞬で最頻値の反例が浮かんであばばばばばっばばばばばばばばｂ
  - こういう低いレベルの"気づき"がまったく出来ない、死にたい
- 4ヶ月ぶりに解いた
 - 最初N個の+-1だけみててWA(3 4 のとき 2 になるのを忘れていた)
 - ので、10^5ぶんを全探索した

D
- 単純な貪欲で頭からiとi+1をswapすればいいと思ってn-1回回したわけですがn回目でまさかのi==が発生するようで、これがわけわがわからん
  - は？？？？？？？？？？？？？？？？？？？？？？？
  - トイレいったら思いついた `4 3 2 1 5`の場合があるのでn番目まで見ないといけない。。。。

#### 073
C
- 辞書して偶数なら0、奇数なら1
- 1つずつみていくので偶数になった瞬間、すなわち「すでに存在している」場合は2になるのが当然なのでその場で消す
- したら結局は辞書のサイズになる
- はい
#### 075
B
- よくある2次元探索
- Bっぽくない気がするけどまあ所詮B、と思ってたらコーナーケースとその直し間違いで3WAくらいくらった
C
- グラフ問題
- 毎回特定の橋がないグラフを作ってDFSで全域木かどうか求める
  - です
- 3ヶ月ぶりに解いた
  - 前回解けてたみたいだけど「辺を取り除く」が生えなくて解説みたよね 退化
  - 隣接行列で辺が通ってるか管理する方法
  - 明らかに前回のやつの解法がスマートに感じる...

#### 077
C
- fxxk 2TLE 2RE
- 馬鹿だから「せやにぶたんや!」まで思いついたくせに、「nibutan(B, ai)してB[idx:]ぶんだけnibutan(C, bi)」するっていう無意味なことやってた
- 3数の大小関係の場合は真ん中の数字を基準にするとうまくいく関係性がある
#### 078
C
- Cの中では最弱
- テストケースの式の意味とかなんでそうなるのかは知らんけど、要はmの数だけ通るか通らないかの状態と組み合わせがあるわけで、最悪2^m回目で通るわけだ
  - というのを式に落として終了
#### 079
C
- Cの中では最弱
 - せいぜい2^3通りなので全部試せばいいだけ
 - eval is evil

#### 081
C
- 方針が立ってからの分岐が勝負
- 加工する必要があるときだけ**適度に**加工する
  - 条件を満たせばギリギリでいい
- 実装とコーナーケース潰しが下手糞すぎて10WA以上喰らった

#### 082
C
- Cの中では最弱
  - と思いきや誤読して3WA...(増やせるかと思ってた)
  - ふつうに数値と登場回数をハッシュなりでもって、多かったら差を、少かったら全部を取り除くカウント

#### 083
C
- 各要素に興味がないので、できるだけ長くするには初項が小さいと嬉しい（A1=x)。そして、できるだけ長くするには, Ai+1もできるだけ小さいと嬉しい (A2はA1の倍数なのでA2=A1+A1)。これを続ける
- かなり簡単な部類に入るC
  - 解説の数式はまったく読めない

#### 084
C
- shitone. 非常にダメ。死にたい。4hと結局解答。マジでダメ。脳が腐ってるうえに文盲みがある。
- 4ヶ月ぶりに挑んで解けたけど非常に頭が悪い
  - シミュレーションでいけると思ってやる
  - c + f * nを満たすnのうちcurrenttimeを超える最小のnを求めるのににぶたんを実装したのはどうやら悪手らしくて、条件から求まるらしいんだけど解説読んでもさっぱりわからん
D
- 10^5だし愚直にやってもいけんじゃねと思ってた時代もありました
  - 間に合わなくて1WA食らった
  - 真面目にやった。累積和+包除原理
#### 085
C
- オーダー見積もり && 整数 の典型
- 以前はrubyで出来てたっぽい -> 10ヶ月ぶりにチャレンジや
- -> ち〜ん
- **上限を2000に**,をしてなかった....2WA..
  - 「これやったことある知ってる〜こうやるんだろ〜」でゴミになった感じが強い
  - 反省しろ
D
- 問題文よむぼく -> あー？？？？？
  - 3分くらいで諦める
- 解説文よむぼく -> は？？？うせやろ・・！！！！！！！！！！！！！
  - Cにしろや
- 4ヶ月ぶりに解いた模様 うっすらと解法を覚えていた感じがする
  - ai<=biなので基本的にbiが強い。最強のaiより弱いbiは使う必要がない
  - 順番は関係ないので選びぬかれたbiを強いほうか使っていって、倒せなかったら最強のaiをHがなくなるまで使う

#### 087
C
- 累積和
 - じゃなくてもNがちいさいので全探索でもいい なんでもいい

#### 088
D
- 懐かしのほぼ典型迷路幅探索
  - 最短経路以外ぜんぶ壁で埋めればいい
  - ゴールできない場合を加味忘れて1WA

#### 089
C
- 考察10秒 -> 組み合わせ出せればいいんやろ -> 実装半日
  - 結局なぜかTLE出てダメで、解説みたらふつうに方針あってたのでキレた
- クソ
#### 090
C
- あれ?過去にほぼ同じの類題やったような
- そのマスを訪れた回数ぶん裏表裏を繰り返すので奇数回訪れたら裏
- n>=3 m>=3のとき奇数回訪れるのは外周以外の、周囲すべてをマスで囲まれた部分のみ
- 余裕

#### 093
C
- 小さい方2つと最大値の差の偶奇で分岐
  - なぜか過去に3WAしてるらしい コード読んだけど読めない

#### 094
C
- N小さいし都度ソートしてもええやる
  - ダメでした
- 解説がなにをいってんのかわからんが、どうせ1ずらしたところで中央値なんて真ん中か真ん中の次（前）の二択なのでそれをとっておいて配列から順番に取り出したやつと比較する感じらしい
- なんで比較してうまくいくかってのはなんかよくわかってないけどノリで書いた
- クソ

D
- アイデアは合ってた
  - 「nCr的に、nは最大でrはnの半分に近いほうがいい」
- ただし実装が大混乱でカオスになってしまったしn時間かかった
  - n時間かけて解答見ずに解けたのはいいが...
- 求めるのはにぶたんかlower_boundなりでみてその後ろと比較する感じ
- アホだったのは、ムダにupper_boundとncrを実装したところと、半分にしたいっつーのに`n//2`とかやってて無限にバグらせていたところ


#### 097
C
- 解説見る -> わからん
- ggって解説記事見る -> なるほど....
- ロジックは単純なんだけど全探索をfor二重でやるのすら思いつかない程度の`permutation`クズ
- 腑に落ちないってことはなく、まあそうだよね感があってあんまりキレはない🤬 

D
- 2時間考えるも何もできず->解説みてunionfindを使うと知る->unionfindをどうやって与えられた配列に適用するのかわからず2時間経過
- 結局ググって回答例見てそれをパクった感じになった
  - なんやこれ 簡単だけど難しくない？？？？？
  - というか未だになんでこれが答えになるのかよくわかってない
  - ansの導出で初めて与えられた配列とsameしているのだがなんだこれ


#### 098
C
- ヒント見てしまった
#### 099
C
- 「N以下の6^pと9^pなんてたかがしれてるんだしそれでgreedyすりゃいいだけじゃね?」->「私は考察のない貪欲をしました」
  - 実際はgreedyだと都合が悪いケースがある。14とか110とか
- dfsを試みるも当然のように時間がダメ
- メモ化再帰しようとするも、1と6と9で[N][~10][~10]では？と無能を呈してしまい無理
- 解説をみるも残念ながら理解できるレベルにあらず、これはどこの言語
- ggったらこれは難問らしく、取り上げたqiita記事まであった
- それを見てメモ化した。dpわからん

#### 100
C
- 考察してないんだけど眺めてたら偶数のこころが生えた

#### 101
- 1で埋めればいいことは思いつく
- 最初「1の両端からk-1ぶん伸ばせばええやんけ」ロジックでやったらWA
  - そりゃそうだ、`2 1 3`で`k=3`のときこれだと2だが、真ん中からやれば1でできる
- 考え方を変えて、1のインデックスとは無関係に頭から出発し初手はk、残りはk-1ずつ伸ばしていけばすべて埋めれると気づく
  - Nが小さいので可能
- 通ってから解説をみたがさっぱりわからん なにこれ
#### 103
C
- 個人的に最速で解けたC
  - うれC
- 余りは割る数以上にはならないので-1したものの総和
- 雑すぎる考察だけどまあそんなもんだ
- 三ヶ月ぶりに解いた
  - 解けたんだけど愚直にlcmを使ってて、MLEなるかと思ったら通ったんだけど、↑の三ヶ月前の実装を見て驚愕した
  - よく当時こんなん生えたな わからんぞ
#### 106
C
- ろくな考察もせずに適当に書いて1waした挙げ句解説をみたのに更に1waを上乗せしたので吊るべき
  - わざわざ正答数が多い簡単な問題を選んだのになんだこの体たらくは お前は生きてる価値があるのか
  - 死
- shitshitshitshitshitshitsthimatherrrrrrrrrfuuuuuuuckkkkkkkkerrreeeeeeeeeeee
- 3ヶ月前にやったやつのやり直し Difficultyの低いやつ選んだのに
- 見たこと有るって言ってたのに無駄に時間かかった 混乱する
  - しかも無駄に2WA 死
#### 109
C
- gcd使う方針はあってたんだけどなぜか使い所がおかしくて
- xiとxi+1の差でgcdを使い
- 1からその差（最大公約数）までの約数のうちで
- Xから最も近いところ（にぶたんで求めた）にいける最も大きい数を求める
- という迂遠な方法でやった gcdの更新をミスって3WA
- すべての提出で一番最初のREが取れない、これはバグでは
- マジで鬱になった
#### 110
C
- 互いに辞書で管理すりゃいいんじゃねという方針だが解けない
  - 実装がわからん
  - 世界一プログラミングが下手 死にたい 鬱になった なんでこんなもんに数時間かけてんだ
- 全探索か？と勘ぐるもこれも数時間やって実装できず
- 諦めて答えみると理解できない
  - これほんとにDificultyこんなもんか？？？？？？？？？？
- と思ってググったらやっぱ相当難しいみたいだぞ
  - と思ったら考え方によっては簡単な解法もあるみたいだぞ。。。

#### 111
C
- 舐めてかかったらどんどん深みにハマった
- のべ半日以上くらいダラダラとやってた気がする
- 「手続きはすぐ思いつくけど実装がまったくできない」タイプ
- fuck
- なんでこうスマートに解けないのか
  - 先天的に脳細胞が欠乏しているとしか思えない、鬱になる
- しかも解説よんでやってもWAなる
  - マジで鬱が悪化する
#### 113
C
- 見た瞬間座圧的なインデックス入れ替えテクでいけるとわかるんだけど、
  - 「座圧ねーはいはい どうすんだっけ」っていう程度の雑魚認識なので調べてへーってなりながら実装したので死にたくなる時間がかかった
  - 自戒
- 0WA
  - 提出してから解説を見に行ったが見ても微塵もわからないタイプの解説なのでふつうにググったほうがいいかもしれない
    - 方針は合ってたのでべつにググって別解とか探してないけどな
#### 114
C
- 「うまい具合に3, 5, 7でスイッチする方法わからんな〜」
- 解説みたら**3or5or7が含まれてるやつ全列挙してあとで全て含んでるか判断**というマジかよってなる手を使うとのこと...oh...
- 実際それでもせいぜい29523個しかないのでソートして探してまでやっても余裕で間に合うという...してやられたわ
#### 118
C
- 観た感じGCDの匂いがするがぜんぜん考察も証明もできず
- まさかなハハッとか思いながらGCD書いたら通った
- 解説読んでも理解できん
- というかそもそもGCDが証明できん
#### 119
C
- もうわけわかんねぇからググったわ
  - 難しい部類に入るらしい
- Nが小さいので実は全探索と気づける
- A,B,C,不採用の4つの状態をそれぞれのやつにもたせて、答えはA,B,Cとの差の絶対値でどれだけインクリメント/デクリメントすればいいかわかる
  - そんで最小値を更新していく
- ってとこに気づいたところで実装も悩む 再帰書けないマンになって死

#### 120
C
- Streakのために簡単なやつを解いた
  - 最終形態は0000か1111かなのでmin(one, zero)*2

#### 121
C
- できるだけ安く済ませたいのでAiで貪欲です おわり
  - なーにが終わりじゃ 3WAくらいした
  - テストでの`print`消しわすれ2件, **Aiが複数回登場する** を見抜けなくて1WA
  - Streakのために簡単なやつを選んだはずなのに死

#### 122
A
- はい

B
- はい。Nが小さいので全探索

C
- Nが大きいので累積和作っといてクエリはO(1)にする
- 3ヶ月ぶりの挑戦。
 - Atcoder ProblemsのProblem ListのDifficultyで低かったので。
 - うっすらと見た覚えがあったのでなんとなく累積和した。rbのバージョンがクソでよくわからんエラー吐きつつもチューニングしてAC

#### 123
C
- ボトルネック

#### 124
C
- 2ヶ月前にやったばかりだったわ
  - Streakが途絶えそうだったので慌ててDifficultyの低いやつをやるという。。
  - そっちのコードはなかなかクレバーだった。最初の文字をキーにして探索するやつ
  - 今回のはインデックスと`b`or`w`の4通りを毎回試す感じで解いた
- 最終状態が一意に定まる系の問題は、実際にやってみるといいかもしれない

#### 125
C
- 負数の数は0か1にできる + 場所は移動できる
#### 125
D
- 任意の2つの符号を変えられるので、負の数が偶数か奇数かで、最終的に残る負の数は0個か1個にできる。1個の場合は最も小さい数を選べばいい

#### 127
D
- 毎度ソートしたりにぶたんしたりする実装を試してたらしくそれは2回ほど挑戦してTLE撃沈してた
- 今回解説を読んで実装
- 要は **「書き換える枚数は確定できる」「cの大きい順にしたものでaの小さい順にしたものを置き換えるイメージ」** という、あっはい、みたいな感じ。ただし実装がなかなかやりにくい
- 尺取っぽくやってみました


#### 129
3完+Dの考察合格。全体的にやさしいというか、アルゴリズムはごく初級レベルでいける

C
- 一次元DP．ABC040でやったばかりだったのでまだ記憶にあった
  - いうて本番では頭がバグって一旦置いた
D
- なんとなく考察は出来たが実装にいたらず。終了後10分ほどで提出したものはTLE
  - コード自体に改善の余地はあるんだけど、そもそもpython(pypy)で解くのつらい？
  - にゃーん..
#### 130
3完 C解けず 初めてコンテスト中にD解けた
C
- 本番で死ぬほど誤読してて、「最小値」かと思ってたので死んだ
 - ちゃんと日本語を読めば解ける最易問題
D
- ふつうに尺取法をやるだけっぽかったけど実装忘れたのでggって出てきたけんちょんさんのqiitaを丸パクリしたりした
  - Cに時間をかけすぎていたせいで提出が遅れてしまった...（本番）

#### 131
死のfloor(2.5)完
C
- 本番中は掛ける数をにぶたんで求めて、これは今でも謎だが最後のケースだけ失敗してた
  - 死
  - 解説一瞬みて生えて死にたくなりながら書いたがサンプルが通らず死のうかと思ってた。
  - B-Aじゃなくて B-(A-1) Aは含むので
- 久しぶりにやった 包除原理は覚えてた
  - **B-Aじゃなくて B-(A-1) Aは含むので** これできなくて死んだ
D
- 締切が近い順にやる（締め切り時間が同じならその中でかかる時間の順番は関係ない）

#### 132
初4完だけどやっぱ相当易化してるので...
C
- Cの中では最弱
  - ソートして真ん中ふたつを比較して終了
- 2019/11/18 解き直したら実装できなくて死ぬかと思った
  - 退化してる 死にたい
D
- 順当に数学的に解く。nCrで球を置く場所を取るのと、二項定理で球の選び方をとって掛け合わせる

#### 141
D
- 最初毎回ソートしてやっててTLEなってた
- 優先度付きキュー知ってるかどうかじゃんねこれ 知ってたら秒で解ける

#### 143
C
- しゃくとりでやった

#### 145
C
- 本番で問題を読み違えて無限にバグらせるし実装もバグりやすい書き方してたのでダメです
- ふつうにpermutationでループするだけっすわ

### ARC
#### 003
B
- ARC Bの中で最弱
  - やるだけ。もとのやつと逆順をセットで持っておいて逆順でソートして順番にもとのやつだけ出力

#### 005
A
- まだABCのC==ARCのAじゃなかった時代？
- 考察1秒 実装10秒
- アルゴリズム以前なので誰でもいけますが0点相当だと思いましょう
 - 言語によるけど3分岐するよりかは入力を変形したほうがいいよね
 #### 007
 A
- まだABCのC==ARCのAじゃなかった時代？
- 例によってアホほど初心者っつーか入門者向けの難易度0
- 回答数を稼ぐためにこんなん解くの情けなくなってきた
#### 010
A
- はい
- 書いてあるとおりにやればいいです
#### 040
A
- シミュ
- 書いてあるとおりにやればいいです
- とくにアルゴリズム的な知識は不要で、配列ができればいいです
#### 042

#### 043
A
- Dificulutiy低いからきました
- 最小値と最大値がわかればpが導出できるのであとはそれをもとにqを導出する
  - すげぇ雑に実装したけどなんとなくあってた
#### 049
A
- はい
#### 057
A
- どうすっかな〜〜って唸ってたんだけどよくよくサンプルみたらすげぇちっさい
  - よくよく考えたらk=2で倍々マンだし最も小さいa, k = 1, 1でも40回はやれば終わる
  - k=0のときはインクリメントになるので引き算
#### 079
A
- 中間を訪れたかどうかもっておいて判定
  - 自分は配列1つだけにしたが、解説みるとtoとfromのぶん2つもっておけばもっと楽だったらしい
#### 080
C
- ARC-Cの中では最弱
  - 奇数の隣は必ず4の倍数
  - `1 4 1`はOKだが`1 4 1 2`がアウトなことに注意して4の倍数と奇数の数を数える
#### 091
A
- 奇数回裏返れば裏になってるので偶数回裏返る場所をはじき出す 

#### 093
A
- 差分取ればいいんだけどその利用の仕方があんまりうまく浮かばずハマった
 - 解説pdfは読めないのでqiitaで適当な記事を探して読んだらわかったけどかんたんすぎてアになった

### AGC
#### 005
A
- AGC Aの中では最弱
  - 今だと100点くらいの問題
  - SはストックのS ストックが続く限りTを消せる

A
- AGCの中では最弱と言おうとしたが最初「ソートした真ん中1/3」だと思いこんで自信満々で出してアウト
  - ソートして「上位から順に1位２位」「下位から適当に3位」で1セット*nが正解
#### 014
A
- シミュだなと気づくのおそすぎて60分くらい溶かした
- all sane odd の場合のコーナーケースが取れず30分くらい溶かした
- 死にたい

#### 015
A
- AGC Aの中では最弱
  - 4WA...
  - 最小値\*n-2~最大値\*n-2で1ずつインクリメントしたものが網羅できる
  - n > 1,  a < bが条件になってないという小賢しい罠

#### 019
A
- こういう問題苦手
- 単純に2L基準の最小値、奇数Lなら更に1L基準でやったやつの最小値を加える

#### 020
A
- Streak用にDifficultyの低いやつをテキトーに選んだ
  - いずれの操作によっても初期位置から変わる互いの距離は2で割ってなるか1なるかどっちか
  - 仕方なく負ける瞬間を考えると、相手に踏まれる場合になる。これには相手が横に立っている必要がある
  - なので、先に横に立たれたら負け
#### 021
A
- 8か9で埋めればいいと思ったけど9だけでいい
- 996と699の結果は変わらないので先頭だけ-1して残りは9でいい
- ただし199とか、オリジナルが最大の場合もあるのでmaxを取る
  - これを忘れて2WAした
  
#### 029
A
- 最終形態から考えるとWの移動距離になる

#### 039
A
- n時間かかった....
- 方針はすぐに立った
  - こういう問題はまず「単体の場合」「連結した場合」でどう変わってくるか考える
  - 先頭と末尾が異なるなら単体の場合をK回やればいいだけ
  - そうじゃないなら「左端」「両端の連続する同じ文字を省いたもの*K」「両端の連続する同じ文字をつなげたもの\*(K-1)」「右端」で足す
- いろいろバグらせていた。。。正味3時間くらい...

### 外部コンテンスト
#### COLOCON -Colopl programming contest 2018- Final（オープンコンテスト）

A
- 前後にAが含まれない場合とAだけの場合とそれ以外の場合で場合分けしたんだけどこれはクレバーではない（TLE, WAを経てのAC）
- 解説が死ぬほど分かりにくい。他の提出を参照するもなんかよくわからん
  - 境界の数？？？？？？で判断？？？？？？？？？？
- Aしかない場合の`(x*(x+1)//n`ググった 数列の和か
 
#### 第二回全国統一プログラミング王決定戦予選（nikkei2019-2-qual)

B
- 最初Dは距離かと思って、以下のような場合にサンプルコード1の答えが3になるので間違ってんじゃないのと思って2時間くらい溶かした
  ```
  (1,2)(1,3)(2,4), (1,2)(1,3)(3,4)のほかに、すべて独立して(1,2)(1,3)(1,4)
  ```
- よくよく読んだら`2 頂点の距離とは一方から他方への最短路に用いられる辺の個数を指します。`と書いてあったので、独立しているのは間違いだと気づく。距離じゃなくてそこに至るまで経たエッジの数だった
- その間違いに気づく前に基本的な方針が立っていてこれがわりとあってた
  - 連結していると考えた時に数の小さいほうに数の大きいほうがくっつく（ソート&&カウント）
  - ので、n個をm人に割り振る場合の数みたいなもん（割り振られない場合もあるので、4個の飴を3人に割り振ると考えると、各飴に3つの行き先があるので`4^3`になる、とかそういう）
- 0になる制約があるんだけど、**最初だけ必ず0で、そこ以外に0は登場しない**しか思いつかなかった
- 重要なやつがあって、**ソートすると必ず順番どおりに数が登場する**すなわち飛び飛びになっていない、というもの
  - 必ず直前の辺が存在する（何度もいうが距離ではなく辺の数なので）
  - わかりにくい
- あとは順々に掛けてやるたびにmodを取る。逆元が必要かと思ってたけどとくにそんなことせずに通った

#### CODEFESTIVAL 2016 Final
B
- 「最大値を求めればあとは再帰的にいけそう？」
  - 「n/2が最大値っぽい？」-> 「いや、15だと[1,2,3,4,5]でいけるので違うか。。。」
  - 「じゃあいいや 愚直に1から足していって最初に越えたところが最大値っしょ」->python3でやったらTLE
  - 「うーんじゃあpypyで...」->通ってしまう
- 解説を観たらこんなことしなくてもよくて、最大値を求めたあとにO(1)でいける。。。
  - 発見されるまでのうちに必ず不要な数が1つだけ含まれている（もしくは存在しない）のでそれを省く
  - 差を取れば、それ。
- 難しかった...

#### diverta 2019 Programming Contest
C
- Dificultyが低かったので。
- 繰り返し系は単体のときと連結のときと分けて考える
  - 単体で完結する（=**連結に影響しない**）ようなやつは最後に加えても一緒なのでテキトーに数えて終了
  - 連結するやつも、両端に作用するのか一方だけなのかで考える。両端は単にそれをつなげていけばいいので楽そう
  - あとは余ったやつを考える

#### DDCC2020 ディスカバリーチャンネルコードコンテスト2020
C
- コンテスト中
  - なんとなく左優先のあと上優先で見ていくとよさそう？なので各座標をソートして...あーめんどくせ諦めた
- 終了後kyopro_friendsのツイートを見て実装
  - 1 各行を高さ1として埋める
  - 2 余ってる行（"#"が登場しなかった行）各列を上or下の列からコピー
- 何気に最初の**各行を高さ1としたとき**の実装がプログラミング
- むずい

#### sumitrust2019
C
- なんとなく手元で実験したら法則性が見えてきたのと、ふつうにやっても間に合いそうなのでそうする
- 本番では9分で終了
  - 令和からのやつのCの中では最弱?
D
- 本番では、たかだか1000通りというのは気づいたけどそれ以上の考察はできず、わりと早めに諦めた
- というのをPython3でやったらなぜかTLE たかだかN*1000なのに...
- pypy3でやったら普通に通った

E
- 本番では、2WAを残して6回ほど提出したがダメだった
- 適当に毎回更新する。いま出てる色の種類の数（それまで出た0の数で適当にインクリメントするなど）してかけていき、最終的にどの数列のルートにどの色を割り当てるかをしてやる。
  - 罠らしい。**0通りが存在する**のでそれをやるなど。。。。
  - 卑怯過ぎる
- 判明。先頭が0じゃないのもあるが、**0が4回以上登場する**という邪悪すぎるパターンがあるらしい。これ問題文から読み取れるのって解説の解法がさっと頭に浮かんだ人限定じゃないか？？？