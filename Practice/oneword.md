## atcoder
### ABC
#### 004
C
- 30回でもとの配列に戻るってのは見てたら2秒で浮かぶのでそれで丸めた範囲だけやる
- はい
 - 独自に余りをだしたらふつうにバグを埋め込んでしまったが問題文通り`mod 5`しましょう
  - `(i-1)%5`とかしててループしてしまってあぼーんなった(わかりづらい)
#### 006
C
- 解けず
  - いつものようにa+b+c=n, 2a+3b+4c=mとやってもダメ（TLEと、なぜかWAが生えてきた）
  - 解説は読めない
  - 他の回答をみるとO(1)でもいけるらしいがぜんぜん読めない

#### 007
C
- ただの超典型BFSなんだけど謎のバグで無駄に時間かかったし結局バグは回避しただけでまっっったく納得がいかない
- キレそう
- 結局はただの超典型BFS
D
- 超典型のdigit DPらしい
  - なにそれ
  - 調べた
- digit DPとかいうやつに初めてあたった。こういうことか
  - 理解するのに半日かかった
  - いうてどうせ典型しか解けないので理解できてないってワケ

#### 010
C
- はい

#### 011
C
- 0からスタートして3,ダメなら2,ダメなら1を加えてく
  - 加えるときにnを越えないという条件
  - ぜんぶダメならもうお前はダメだ
- カウントの上限と最初からn==ngの場合をちゃんと考えておく
- dp解があるらしいがまったくわからん

#### 012
C
- あんま解いても意味ないC
- 数学でもアルゴリズムでもデータ構造でもない さんすう

#### 014
C
- いもす法入門
- どっかでみたな〜〜っつって公式みたら問題例そのまんまっぽい感じのやつ
- 完全に忘れていたので一読した
- いい加減そらで書けるくらいになりたい..
  - 0WAだったけど自戒を込めて
- 3ヶ月ぶりに解いた。前回のは覚えてない
  - 典型imosが浮かんだ
  - n,a,b=1,0,0のコーナーケースでWAなるコードを書いてしまった...
#### 015
C
- nもkも小さいのでそのままDFSして見つけたら終了っていう脳筋
- DFSとxorの問題
  - xorは直近やった121Dで出てきたばかりだけどどうせ小さいのでなんも効率化せずに回した
- クソ寝ぼけてて頭が働かなかったのでこの程度の低レベルな再帰ごときに時間をかけてしまった
  - dfsの再帰のこういう形（ひとつだけの解を出すため呼出し元にreturnしたりはしない）っていうのは好きじゃない
- shit one.
#### 016
C
- 解説が一切わからん。は？最短経路？
- 適当に二次元リストで友達のIDを保存していくとなんかどっかで重複するっぽいんだけどわけがわからず、それもリスト取って確認したら重複してるやつ除けばいいっぽいのでそうしたんだけど原因が一切わからん
#### 019
C
- また問題文を読んでなかったやつ
  - 与えられる配列から[i]*2 = [j]になるやつを探すのかと思った
- domn
#### 026
C
- いや再帰するだけなんだけど。rubyがクソなせいでreturnの部分のクソ簡単なバグが取れずに数時間溶かしたのでキレ気味に追加
#### 029
D
- 「桁dpの問題」みたいなリンクからやった
- 解法ヒントがあればまあその程度って感じ
  - 1ってのがミソで、単に数えたものの総数なので最大でも桁ぶんしか無い
  - ので、メモリに乗る程度のメモ用テーブルが組める
#### 032
C
- 文字読めないから順序うんぬんを飛ばして読んでて、「ソートして頭からやればいい」と思い込んでた
  - キレて解説みたらは〜ん？となった
- 尺取法とかいうのを解説に沿って実装したが3ケースでTLEになる クソ
  - 積をいちいち計算してたらダメらしく、計算結果をもつ変数をもたせると3WAなる クソ
- 結局わけがわからんが、r == lとなったときにr+=1して結果を1にするみたいなことをするといけるらしいがまるでわけがわかりませんね、クソ
#### 034
C
- 数時間かけたが一切理解できなかったので諦め問題
- 俺たちは何回「こんなんDPでいけるやろ典型」とか言って挑戦して玉砕してるのか？
  - ついさっきやった（2019/03/05 23:36 戒め）
- フェルマーの小定理？？？？？？？？？なにそれ
  - ggって唯一納得のいく説明[https://www.surweb.jp/sur/faq/fermat1.html](https://www.surweb.jp/sur/faq/fermat1.html)
- 逆元？？？？？？？？？？？？？？？？？？なにそれ
  - なんで逆元を求めればいいのかさっぱりわからん無理。階乗の話じゃないの？
- 繰り返し二乗法?????????????????????????????????????なにそれ


#### 035
C
- fuck. いもす法とか知らない。なんか頻出いうわりに初めて知った。使い方も実装も（この問題では）簡単だったけどたぶんいつもの典型以外解けないやつだろ
- あと解説文に騙されたが冷静に考えればi番目をi+1に加算ってのは嘘でiにi-1を加算だろうが

#### 037
C
- ↑C35ひと月前にいもすとか知らないと書いてたな、まだ1次元だけだが相当出てくるぞ > 1月前の俺
- 変形いもすであぶれたぶんを引いていく感じ
- 実装はなんか泥臭いというかもっと工夫できたんじゃないかな

- 4ヶ月ぶりに解き直した
  - いもす？普通に累積和してACだが？
    - 累積和とっといて範囲外の最大から範囲外の最大を引けば範囲内の総和が求まるんじゃね的な
  - とか思って前回解いたやつみたらなるほどね いもすじゃないけどねこれ
   - kから始める、を考えず、0~nまでやるんだけどk未満は無視、は確かに。無駄だけどこっちのが考えるの楽だな

#### 038
C
- ACしたけど解説みたらああそんなアルゴリズムあったね...ってなった
- 単調増加しなくなるまで長さをとっておいて、しなくなったときの長さをLとすれば∑(L)個出るのでそれを足していく、最後に残ったLもちゃんと処理する、っていう方針でやった
- 言うまでもなく解説の尺取法使ったほうがスマートでクレバー
  - 計算量は変わらん せいぜい∑(L)のぶんがネックになる程度

#### 040 
全体的に脳死お断りな気がする（実力）

C
- 超典型DP
- よくよく考えれば`dfs(i, cost)`や`dfs(i, step)`なんかのメソッドは必要なく、単にDPの配列のみで良いことに気づく（2REして意味不明なったんで答えみたらわかった）
  - そもそも **蟻本曰く、引数にコストを含めるのは愚**なので`dfs(i, cost)`はダメ
#### 041
C
- kuso. 座圧的な発想はすぐに浮かんだ、まではいいんだけど
- その座圧の実装がどうやるか思い出せず、配列っしょwと思ってたわ
  - 辞書でした。死ぬべき
    - 解説みるとふつうにpairでもいけるので、べつに辞書にとらわれる必要はなくて、単にお前の頭がゴミだったってだけ pgr
- マジで何年やってんだ 脳味噌腐ってんじゃねぇのか
- さっきなんも見ずにpythonで実装したら一発だったんだけど、発想が座圧なのは浮かぶけど座圧の実装は忘れた。愚直にリストでやった
#### 042
C
- インクリメントするか...いや間に合わないか
  - 一文字ずつとってみるか...いや上下どちらからやっても繰り上がりがうまくできんな...
  - どうすっかな...激ムズだな...
  - 解説みる -> クソでした死にます
- さっき4ヶ月ぶりにやり直した。問題読んで場合分けめんどくさいなーとか思いつつ10分くらいtwitterに逃げてて、戻ってきてから「N<=100000だしインクリメントでいいんじゃね」となってやったら通りました
D
- dpマップを作ったところでnCrの計算ができず、ひとつずつ見ていく想定でやってたので間に合わないことに気づく。
  - -> 死亡
- 死亡したので解説を読む。ちっともわからん。
  - 1ググりして出てきた[これ](http://tatanaideyo.hatenablog.com/entry/2016/07/24/031338)を読んで（これは公式の解説とは別の解法だが）わかった気になったつもりになり、実装はせず
- ムズい なんだよフェルマーの少定理て nCrて これは数学です
#### 043
C
- 「minとmaxのmid（+1 if odd）したやつをターゲットにすればいいかな...」
  - なぜか負数があるがこの考えだと無意味なんだよな引掛けか？？
  - もちろんなんの根拠もないし考察なんてしてない、サンプルが通るだけ
- 解説みる -> マジでクソ。
- > この時-100から100 までの整数しか考える必要はない。(-100未満や100より大きくしても、各(ai-X)^2はX=-100や100の時と比べ大きくなるだけなので、無駄。)
- これの意味がわからんけど、要は
  - ai=100のときは100にしたら(x-y)^2=0になる、100より上だと増えていく
  - ai=-100のときは-100にしたら同じく0になる
  - っていうことだろう
- いずれにしろWAしたしクソ
- 4ヶ月ぶりに解いた。ひと目で(max-min)/2を目指せばいいやんと思いこんで以前書いたコードを見て驚愕した。全探索。。。制約をちゃんと読もう....
  - 精進問題....
D
- 初のなんも見ずに解いたD
  - 🎉
  - 考察もだいたいあってた
  

#### 044
C
- 「途中でぶった切る再帰で十分だろ」->「げぇっ最後のサンプル確かにこういう場合があるのか...確かに..」
- で解説みた
- まあふつうにdpだったんですが変数のもたせ方にまったく自信がなくてそのへんは解説見た
  - 三次元dpで50\*50\*2500ってのは直感なんだけど、そんなでかい数値ありえねぇだろってのもまた直感
  - ふつうに計算すれば間に合う感じでした
- メモ化再帰を組めるのは楽しい
- だがfuck 何時間かけてかいたんだこの程度に
#### 045
C
- 愚直解しか思いつかなかったのでやったが実装がハゲそう
  - 途中で耐えきれなくなって解説をみたら愚直解だったのでなんとか書ききった
  - つらい
- 合計値を出すメソッドよく書けたなこれ...
- いくつ入れるか+どこに入れるか、でnからc個とる組み合わせのやつをc++していったのだが、解答のやたらと短いやつをみると「+をいれるかいれずにつなげるか」のdfsっぽいのがあったのでぎゃふん
- pythonで解き直し。以前の回答は見てない
  - eval is evil
  - 愚直回しか思いつかない。再帰で入れるかどうか判断していく
  - Cのわりに簡単すぎる。200くらいでいいんじゃないか。再帰入門的な
#### 046
C
- shit one.
- 地道にインクリメントして当然のようにTLE
  - じゃあにぶたんで求めるか〜ってところで鬱になったので1秒で諦めたのだが、ggるとにぶたんでやってる人もいた（通るらしい）
- 解説をみたが1bitも理解できないのだが...?
  - 比になるのはいいとしてなんで *このようなxは~で計算できます*になるのだ
  - なんで計算できるかをしりたいのだが?
- 解説例の解説 わかった気になる [https://ameblo.jp/weibeicun/entry-12438868527.html](https://ameblo.jp/weibeicun/entry-12438868527.html)
D
- DPかなと思って実装したがN=20程度でも帰ってこず、死
- 答えみた
  - マジかよ考察力....
  - 相手も同じルールってのが抜けてたわ
  - これは太刀打ちできん考察問題のレベルを感じる
#### 047
C
- 頭からみていってシミュレーション的に変えていくのを思いついて、よさそうだというところで、実装の前に**以前かいたやつを見てしまい**、それは解説を読んだやつっぽかったんだけど,自分が思いついたやつよりも更に一歩考察を進めたものだった。。。。
  - 死
#### 048
C
- 前やったのを覚えていちゃった
#### 049
C
- 「ははーんこれは幅優先だな」 -> あぼーｎ
- 解説みる -> は？？？？？？？？？？？？？？（激怒）
- これはひどい
- 4ヶ月ぶりに解き直した
 - 解法覚えてた
 - なぜか意味不明なことに1WAして完全に意味不明なったけどな
#### 050
C
- はい
  - 履歴消えた？？？？？
- 最初から考察は出来ていたっぽいのだが現行atcoderのrubyのバージョンが時代錯誤すぎて1WA,仕方なく直したやつでTLEを喰らった
- ので、別の視点から書いた
- nから配列は一意に同定できるのでそれを出して比較
- 見てりゃわかるし難易度はミドリムシ程度
- fuck one damn it shit kill

#### 053
C
- damnit. 計算はだいぶ悩んで浮かんだ。ただし実装がクソ
- 死にたい
#### 055
C
- 考察あってたんだけどなぜか実装でそれに従わないゴミ回答をしてしまい1WA...
- 問題自体はAレベルのさんすうだっただけにクソ
- 4ヶ月ぶりにぶりに解き直し
  - 方針は1秒だったけどなんかしらんけど場合分けをバグらせてハマった......退化....
#### 056
C
- 何回か挟んで考えた 
  - そのうち何度かはクソ
- 提出したやつはまとも
  - ただ、`10**9`ということで、最初にぜんぶとってからの累積和、というのは最初に取る段階でTEFなるのでダメ
- 以下かんがえたやつ
- A[n]からA[n-1]までの数は問題の性質からそれまでのA[i]を調べて任意の数を取って並び替えればどれかは達成できるやつになってる
  - なので適当に累積和っぽいこと(TLEなるのでメモリにはおけない)をやっていって更新してく感じ
  - わりと思いつかなかった 死
#### 057
C
- 一年前にgoで解いてたらしい
- 今回pyでやったんだけど、解けたんだけどgoの答えみたらクレバーだったしなかなかに時間かかったので負けです
 - goでやったやつ range sqrt(n)してiで割り切れる最もデカいのを保存しといて最後に商との桁を比較
 - pyでやったやつ 素数以外として、10^10なら最大で5桁までをみればいいのでふつうに全探索したあと↑
- 微妙に思考過程が違ってて面白い
#### 058
C
- 前回は4ヶ月ほど前にrubyで出したらしい。今回pythonで解いてから.rbのほうをみた。基本的な方針は同じで、実装が少しクレバーだった
  - 最初のやつを基準にしてそこに含まれているものだけを考える、とか
  - 今回はわざわざN個文のアルファペット辞書を用意して、N回回してからもう一度最小値を取るために回して、というのをしたが、最小値も都度更新できるので。
- 現時点でatcoderのpythonのバージョンが低いため辞書が順番を保持しておらず1WA。
#### 062
C
- n回くらいトライしててぜんぶ同じ戦法（3で割った商を越える最小のw\*iかh\*jを抜いたものを2で割った商を越える最小のw\*iかh\*jを導出）でやったんだけどいずれもクソ
  - 考えすらあってるのかわからんけど
- 答えみたらパターンで全探索だった
  - は？パターン？
  - abcで分けるとするとこうなるよねっていう図式 納得いかん
  - 解説読んだらとりあえず解けたけどこんなもん誰も浮かばんだろ
  - しかも*4パターンのうち2パターンはもう一方のh, wを入れ替えたもの*とか*できるだけ差が小さくなるってことで二分でいい*とか細かい気付きも要求される
  - 非常にダメ
  - 自尊心死んだ
  - こんなもんに数時間かけたのマジで鬱なる
  - キレたし泣いた
  - デカい声では？？？？？？？？？っつってたら近所のおじさんに怒られたのでマジで死にたい

#### 063
C
- 点数が大きいほうが嬉しいので、10の倍数にならないように低い点数を引く

#### 064
C
- いやこんなんふつう最大8色って思わない？問題文じゃなくて例題にしれっと「紫」「黒」とか書くの悪問でしょ
- あとなんかしらんけど`array[8]`にしてまだとってなかったら=1にして最後にsumする、ってやつだとなぜか2ケースでWAで、`bool[8, false]`してあったらtrueにして最後にtrueを数えるっていう、まったく同じロジックのやつだと通る。これはpythonとrubyで試したけど完全に謎。バグでは
#### 066
C
- 4ヶ月前もやってて通してたっぽい
 - Cの中でも最弱
- 似たような発想だが、今回は後ろから作っていっているのに対し、前回のは（なんかたぶん前からやるような）別のアプローチでやっている模様
  - なお前回やっていた記憶はまったくない。記憶に残らない程度の簡単な問題ということだろう

#### 068
C
- 何回かにわけてアタック
  - いずれもすぐ諦めてたけど
- さっきの試行で、a==1以外とb==N以外はみなくていいって気づいた
- ので、適当に実装
  - いうて1時間くらい？かけたんちゃう
  - 映画みたり酒飲みながらだけど
- 意外とうまくいってうれpのだが数回アタックしたのでダメ
- 三ヶ月ぶりに解いたらしい
  -うっっすらと記憶に無い
  - 三点で考える場合は中間地点の気持ちになる。今回は始点と終点が決まっているのでめっちゃ楽


#### 069
C
- 4の倍数と奇数だけに注目すればええやんけ〜
  - 無事死亡
- キレそうになりながらコーナーケースとダメケースを考察したら思いつくまで少し時間かかった
  - それはいいのだが実装までも無駄に時間を喰ったのがマジで気に入らない
- fuck
#### 070
B
- ついにBごとき問題でもWAをやらかした
  - マジで死ぬべきだと思う
  - こんなんを間違うやつが生きてても世界になんの役にも立たない
- は？？？？？？？？？？？？？？？？？？？？？
C
- 読んだらlcmを求めるってことくらいは理解できる
- なので全体のlcmを求める
  - 公式知らんかったのでggった
- アルゴリズムのコアの実装は合ってたけど渡す値と答えをミスってて1WA
- まあアルゴわかってただけでいいっしょ

#### 072
C
- scum.
- 最初最頻値+-1を足してて2WA.
  - マジでこれしかないだろと思ってた
- 諦めて解説読むとあばばばばばばばば
  - 一瞬で最頻値の反例が浮かんであばばばばばっばばばばばばばばｂ
- こういう低いレベルの"気づき"がまったく出来ない、死にたい
#### 073
C
- 辞書して偶数なら0、奇数なら1
- 1つずつみていくので偶数になった瞬間、すなわち「すでに存在している」場合は2になるのが当然なのでその場で消す
- したら結局は辞書のサイズになる
- はい
#### 075
C
- 毎回特定の橋がないグラフを作ってDFSで全域木かどうか求める
- です
#### 077
C
- fxxk 2TLE 2RE
- 馬鹿だから「せやにぶたんや!」まで思いついたくせに、「nibutan(B, ai)してB[idx:]ぶんだけnibutan(C, bi)」するっていう無意味なことやってた
- 3数の大小関係の場合は真ん中の数字を基準にするとうまくいく関係性がある
#### 078
C
- Cの中では最弱
- テストケースの式の意味とかなんでそうなるのかは知らんけど、要はmの数だけ通るか通らないかの状態と組み合わせがあるわけで、最悪2^m回目で通るわけだ
  - というのを式に落として終了
#### 079

#### 083
C
- 各要素に興味がないので、できるだけ長くするには初項が小さいと嬉しい（A1=x)。そして、できるだけ長くするには, Ai+1もできるだけ小さいと嬉しい (A2はA1の倍数なのでA2=A1+A1)。これを続ける
- かなり簡単な部類に入るC
  - 解説の数式はまったく読めない

#### 084
C
- shitone. 非常にダメ。死にたい。4hと結局解答。マジでダメ。脳が腐ってるうえに文盲みがある。
- 4ヶ月ぶりに挑んで解けたけど非常に頭が悪い
  - シミュレーションでいけると思ってやる
  - c + f * nを満たすnのうちcurrenttimeを超える最小のnを求めるのににぶたんを実装したのはどうやら悪手らしくて、条件から求まるらしいんだけど解説読んでもさっぱりわからん

#### 085
C
- オーダー見積もり && 整数 の典型
- 以前はrubyで出来てたっぽい -> 10ヶ月ぶりにチャレンジや
- -> ち〜ん
- **上限を2000に**,をしてなかった....2WA..
  - 「これやったことある知ってる〜こうやるんだろ〜」でゴミになった感じが強い
  - 反省しろ
D
- 問題文よむぼく -> あー？？？？？
  - 3分くらいで諦める
- 解説文よむぼく -> は？？？うせやろ・・！！！！！！！！！！！！！
  - Cにしろや
- 4ヶ月ぶりに解いた模様 うっすらと解法を覚えていた感じがする
  - ai<=biなので基本的にbiが強い。最強のaiより弱いbiは使う必要がない
  - 順番は関係ないので選びぬかれたbiを強いほうか使っていって、倒せなかったら最強のaiをHがなくなるまで使う

#### 089
C
- 考察10秒 -> 組み合わせ出せればいいんやろ -> 実装半日
  - 結局なぜかTLE出てダメで、解説みたらふつうに方針あってたのでキレた
- クソ
#### 090
C
- あれ?過去にほぼ同じの類題やったような
- そのマスを訪れた回数ぶん裏表裏を繰り返すので奇数回訪れたら裏
- n>=3 m>=3のとき奇数回訪れるのは外周以外の、周囲すべてをマスで囲まれた部分のみ
- 余裕
#### 094
C
- N小さいし都度ソートしてもええやる
  - ダメでした
- 解説がなにをいってんのかわからんが、どうせ1ずらしたところで中央値なんて真ん中か真ん中の次（前）の二択なのでそれをとっておいて配列から順番に取り出したやつと比較する感じらしい
- なんで比較してうまくいくかってのはなんかよくわかってないけどノリで書いた
- クソ
#### 097
C
- 解説見る -> わからん
- ggって解説記事見る -> なるほど....
- ロジックは単純なんだけど全探索をfor二重でやるのすら思いつかない程度の`permutation`クズ
- 腑に落ちないってことはなく、まあそうだよね感があってあんまりキレはない🤬 
#### 098
C
- ヒント見てしまった
#### 099
C
- 「N以下の6^pと9^pなんてたかがしれてるんだしそれでgreedyすりゃいいだけじゃね?」->「私は考察のない貪欲をしました」
  - 実際はgreedyだと都合が悪いケースがある。14とか110とか
- dfsを試みるも当然のように時間がダメ
- メモ化再帰しようとするも、1と6と9で[N][~10][~10]では？と無能を呈してしまい無理
- 解説をみるも残念ながら理解できるレベルにあらず、これはどこの言語
- ggったらこれは難問らしく、取り上げたqiita記事まであった
- それを見てメモ化した。dpわからん
#### 101
- 1で埋めればいいことは思いつく
- 最初「1の両端からk-1ぶん伸ばせばええやんけ」ロジックでやったらWA
  - そりゃそうだ、`2 1 3`で`k=3`のときこれだと2だが、真ん中からやれば1でできる
- 考え方を変えて、1のインデックスとは無関係に頭から出発し初手はk、残りはk-1ずつ伸ばしていけばすべて埋めれると気づく
  - Nが小さいので可能
- 通ってから解説をみたがさっぱりわからん なにこれ
#### 103
C
- 個人的に最速で解けたC
  - うれC
- 余りは割る数以上にはならないので-1したものの総和
- 雑すぎる考察だけどまあそんなもんだ
#### 106
C
- ろくな考察もせずに適当に書いて1waした挙げ句解説をみたのに更に1waを上乗せしたので吊るべき
  - わざわざ正答数が多い簡単な問題を選んだのになんだこの体たらくは お前は生きてる価値があるのか
  - 死
- shitshitshitshitshitshitsthimatherrrrrrrrrfuuuuuuuckkkkkkkkerrreeeeeeeeeeee
- 3ヶ月前にやったやつのやり直し Difficultyの低いやつ選んだのに
- 見たこと有るって言ってたのに無駄に時間かかった 混乱する
  - しかも無駄に2WA 死
#### 109
C
- gcd使う方針はあってたんだけどなぜか使い所がおかしくて
- xiとxi+1の差でgcdを使い
- 1からその差（最大公約数）までの約数のうちで
- Xから最も近いところ（にぶたんで求めた）にいける最も大きい数を求める
- という迂遠な方法でやった gcdの更新をミスって3WA
- すべての提出で一番最初のREが取れない、これはバグでは
- マジで鬱になった
#### 111
C
- 舐めてかかったらどんどん深みにハマった
- のべ半日以上くらいダラダラとやってた気がする
- 「手続きはすぐ思いつくけど実装がまったくできない」タイプ
- fuck
- なんでこうスマートに解けないのか
  - 先天的に脳細胞が欠乏しているとしか思えない、鬱になる
- しかも解説よんでやってもWAなる
  - マジで鬱が悪化する
#### 113
C
- 見た瞬間座圧的なインデックス入れ替えテクでいけるとわかるんだけど、
  - 「座圧ねーはいはい どうすんだっけ」っていう程度の雑魚認識なので調べてへーってなりながら実装したので死にたくなる時間がかかった
  - 自戒
- 0WA
  - 提出してから解説を見に行ったが見ても微塵もわからないタイプの解説なのでふつうにググったほうがいいかもしれない
    - 方針は合ってたのでべつにググって別解とか探してないけどな
#### 114
C
- 「うまい具合に3, 5, 7でスイッチする方法わからんな〜」
- 解説みたら**3or5or7が含まれてるやつ全列挙してあとで全て含んでるか判断**というマジかよってなる手を使うとのこと...oh...
- 実際それでもせいぜい29523個しかないのでソートして探してまでやっても余裕で間に合うという...してやられたわ
#### 118
C
- 観た感じGCDの匂いがするがぜんぜん考察も証明もできず
- まさかなハハッとか思いながらGCD書いたら通った
- 解説読んでも理解できん
- というかそもそもGCDが証明できん
#### 119
C
- もうわけわかんねぇからググったわ
  - 難しい部類に入るらしい
- Nが小さいので実は全探索と気づける
- A,B,C,不採用の4つの状態をそれぞれのやつにもたせて、答えはA,B,Cとの差の絶対値でどれだけインクリメント/デクリメントすればいいかわかる
  - そんで最小値を更新していく
- ってとこに気づいたところで実装も悩む 再帰書けないマンになって死

#### 120
C
- Streakのために簡単なやつを解いた
  - 最終形態は0000か1111かなのでmin(one, zero)*2

#### 122
A
- はい

B
- はい。Nが小さいので全探索

C
- Nが大きいので累積和作っといてクエリはO(1)にする
- 3ヶ月ぶりの挑戦。
 - Atcoder ProblemsのProblem ListのDifficultyで低かったので。
 - うっすらと見た覚えがあったのでなんとなく累積和した。rbのバージョンがクソでよくわからんエラー吐きつつもチューニングしてAC

#### 123
C
- ボトルネック

#### 124
C
- 2ヶ月前にやったばかりだったわ
  - Streakが途絶えそうだったので慌ててDifficultyの低いやつをやるという。。
  - そっちのコードはなかなかクレバーだった。最初の文字をキーにして探索するやつ
  - 今回のはインデックスと`b`or`w`の4通りを毎回試す感じで解いた
- 最終状態が一意に定まる系の問題は、実際にやってみるといいかもしれない

#### 129
3完+Dの考察合格。全体的にやさしいというか、アルゴリズムはごく初級レベルでいける

C
- 一次元DP．ABC040でやったばかりだったのでまだ記憶にあった
  - いうて本番では頭がバグって一旦置いた
D
- なんとなく考察は出来たが実装にいたらず。終了後10分ほどで提出したものはTLE
  - コード自体に改善の余地はあるんだけど、そもそもpython(pypy)で解くのつらい？
  - にゃーん..
#### 130
3完 C解けず 初めてコンテスト中にD解けた
C
- 本番で死ぬほど誤読してて、「最小値」かと思ってたので死んだ
 - ちゃんと日本語を読めば解ける最易問題
D
- ふつうに尺取法をやるだけっぽかったけど実装忘れたのでggって出てきたけんちょんさんのqiitaを丸パクリしたりした
  - Cに時間をかけすぎていたせいで提出が遅れてしまった...（本番）

### ARC
#### 005
A
- まだABCのC==ARCのAじゃなかった時代？
- 考察1秒 実装10秒
- アルゴリズム以前なので誰でもいけますが0点相当だと思いましょう
 - 言語によるけど3分岐するよりかは入力を変形したほうがいいよね
 #### 007
 A
- まだABCのC==ARCのAじゃなかった時代？
- 例によってアホほど初心者っつーか入門者向けの難易度0
- 回答数を稼ぐためにこんなん解くの情けなくなってきた
#### 010
A
- はい
- 書いてあるとおりにやればいいです
#### 040
A
- シミュ
- 書いてあるとおりにやればいいです
- とくにアルゴリズム的な知識は不要で、配列ができればいいです
#### 042
#### 049
A
- はい
#### 057
A
- どうすっかな〜〜って唸ってたんだけどよくよくサンプルみたらすげぇちっさい
  - よくよく考えたらk=2で倍々マンだし最も小さいa, k = 1, 1でも40回はやれば終わる
  - k=0のときはインクリメントになるので引き算
#### 079
A
- 中間を訪れたかどうかもっておいて判定
  - 自分は配列1つだけにしたが、解説みるとtoとfromのぶん2つもっておけばもっと楽だったらしい

### AGC
#### 020
A
- Streak用にDifficultyの低いやつをテキトーに選んだ
  - いずれの操作によっても初期位置から変わる互いの距離は2で割ってなるか1なるかどっちか
  - 仕方なく負ける瞬間を考えると、相手に踏まれる場合になる。これには相手が横に立っている必要がある
  - なので、先に横に立たれたら負け