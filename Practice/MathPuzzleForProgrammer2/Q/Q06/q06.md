## 問題名
長方形から作る正方形
## キーワード
再起
## 概要
長辺が1000以下である長方形から長方形の短辺を一辺とする正方形を作り、そのぶん長方形から引いて新たな長方形を作るという操作を続ける。最終的に正方形の数が20個になるような縦と横のペアの総数
## 方針と読解
2<=h<=1000, 1<=w<hについて毎回チェックする。w<hのとき次の長方形は(w, h-w)となり、w>hのとき(w-h, h)となる。このとき作成した正方形1個のぶんを足して再度同じ処理をする。

w, hいずれかが1のときは他方ぶんの1x1の正方形ができるのでそれを足して返す。

goでの実装。こんな再起にした
```go
func recursion(w, h, boxcount int)int{
    if boxcount>20{
        // boxcountが20を超えた時点で無理
        return 0
    }
	if (w==0 || h==0){
        // 残りの縦横が存在しないのでここで精算
		if boxcount==20{
			return 1
		}else{
			return 0
		}
    }
	if (w==1 || h==1) {
        // いずれかが1だと他方の長さぶんの1x1の正方形ができる
		return recursion(0, 0, boxcount+w*h)
	}
	if w<h{
		return recursion(w, h-w, boxcount+1)
	}else if w>h{
		return recursion(w-h, h, boxcount+1)
	}else{
        // w==hの場合、残った長方形とは正方形である
		return recursion(0, 0, boxcount+1)
	}
}
```

実は10WAくらい出している。**終了した時点での正方形を数える**というのをやらずにふつうに20になった時点でカウントしてしまい桁が一つ多くなったり、`w==h`のケースは存在しないと思いこんでいたりしていた。

↑から1年、rubyでやってみた。方針として一回につき正方形を削り出せる量は`y%x`個あるのでそれで回すことにした。`縦と横を入れ替えたものは同じ`は、内側のループの上限を外側で回ってるループまでとすることで実現した。
```ruby
ans = 0
1.upto(1000).each do |y|
  1.upto(y).each do |x|
    i, j = y, x     # 最初これをしてなくてやってたらyが更新されちゃってずっと1のままというバグをやらかしてた
    next if i == j  # これは正方形
    count = 0
    while j >= 1 do
      count += i/j
      i, j = j, (i % j)
    end
    if count == 20
      ans += 1
    end
  end
end

puts ans

```
0WAだがコメントの箇所で脳みそが湧いた

## 参考
なし
## 所感
愚直に実装した。通らなくて泣きそうになった

いちおう答えが合ってるのを確認してから解説を読んだがまあロジックは同じ。実装ちょっとよくわからんけどなんかクレバーな感じ。

-----

↑から1年、rubyで書いてみた時点での所感。まあうまくループ回すだけなのさんすうなので大したことはない。