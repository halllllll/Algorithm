## 問題名
Graph II - Minimum Spanning Tree

## キーワード
グラフ, 最小全域木, DFS, プリム法, クリスカル法

## 概要
nxn行列のi行j列はエッジiからエッジjまでのコストを表し、形成されるグラフは連結木である。最小全域木のコストを出力する

## 方針と読解
（狭い意味で）グラフアルゴリズムを知らんかったのでやってみるやつ。ここで求められるのは最小全域木という。
### プリム法
プリム法実装するの初めてで適当にggったりなんかしたりして本みたらなんとなく理解

- 適当なノードからはじめ
- そこから伸びるエッジのうちもっともコストが低いやつを採用しノードを追加
- そこにいたるまでのコストも更新しておく
- すべてのノードをたどったら終了

やってみたのが **行ったことのないノードの管理** とかがしんどい。あと**毎回次のノードの探索にO(V)かかる**のがしんどい。このへんはpriority queueで高速化できるらしいがprim自体実装がめんどくさいし実はよくわかっていないままコピペしたようなもんなのでダメ

### クラスカル法
プリム法と異なり,
- 小さいエッジからはじめ
- そこにつながるエッジのうちもっともコストが低いやつを採用しエッジを伸ばす
- すべてのエッジをたどったら終了

というやつで、最初からエッジをコスト順にソートして探索する方針でいいらしい（証明ができんけど）。

特徴として、選択したエッジが作ろうとしている木に属しているかどうかの判定に**Union-Find**を使うらしいので適当に実装する。こっちのほうがprimに比べ理解も実装もしやすい。[実際みんなそう思ってるらしい](https://togetter.com/li/776049)
## 参考
プリム法は螺旋本を「はっはっはわっかんねぇや」っつって書いた。ぜんぜんわからん

クラスカル法の説明はなかったのでggってわかりやすかったやつ
[http://yambe2002.hatenablog.com/entry/2015/11/11/110911](http://yambe2002.hatenablog.com/entry/2015/11/11/110911)

## 所感
プリムまったくわからんのでクラスカルにします。クラスカルはunion-find含めても実装が簡単。