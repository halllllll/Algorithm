## 問題名
Partition
## キーワード
ソート

## 概要
配列の基準を決めて基準から左側に基準より小さい数、右側に大きい数がくるようなソートをする

## 方針と読解
> partition ( A, p, r )は、配列 A[ p..r ] を A[ p..q － 1] の各要素が A[q] 以下で、A[ q +1.. r ] の各要素が A[ q ] より大きい A[ p..q － 1] と A[q + 1..r ] に分割し、インデックス q を戻り値として返します。

らしいのでそれっぽいのを実装する。問題では配列の最後の要素が基準の要素になる

- 配列Aと基準となる要素rが与えられる
- i = -1, 0<=j<len(A)
- A[j]<=A[r]のとき
    - i+=1
    - A[i]とA[j]を交換
- A[r]<A[i]
    - とくになにもしない

### だから結局これはなにをしているんだ
AOJに解説があるが、10^5回読んでもわからないので自分なりに解釈した。ざっくりとした方針としては
- 配列の最後の要素をpivotとする
    - 最終的な配列は、pivotより左側にpivotより小さい数値が、右側に大きい数値がくるようなもの
- 配列のインデックスで **「これより右側はpivotより大きくなるもの」** を示す変数`i`を定義しておき、**走査する範囲の最小値-1**にしておく。
    - なぜ-1するのか、は、なんというか実装上の全体的な便宜のためこうしているとしか書きようがない。**そういうことにすればうまくいくから**という実装は悪手だと思うし覚えられないのだが...納得がいかん
- 配列を先頭から最後の要素の一つ手前までループでみる
    - 一つ手前なのは、どうせ最後はpivotと定義しているのでループを抜けてから別個に処理すればいいから
- いまみている要素とpivotの大小を比較
    - 大きい場合は何もしない
    - 小さい場合は`i`より（`i`を含む）左側にあってほしいので、インクリメントして、配列の`i`番目の要素と今見ている要素を交換する
- ループをぬけたらpivotと配列の`i`+1番目の要素を交換する
    - `i`番目の要素はpivot以下で、`i`+1番目からはpivotより大きくなるので。

という感じ。pivotを随時入れ替えるわけではなく、一種門番のような役割を`i`が果たしている。


### ruby
```ruby
def partition(a)
  length = a.size
  r = length-1
  i = -1
  (0...length).each do |j|
    if a[j] <= a[r]
      i+=1
      # puts "#{a[j]}と#{a[i]}交換"
      a[j], a[i] = a[i], a[j]
    else
      # puts "#{a[r]}<#{a[j]} とくになにもしない"
      next
    end
  end
  return a
end
```

## 参考
該当するページにある擬似コード

## 所感
はい。応用が思いつかん