## 問題名
Set - Disjoint Set: Union Find Tree

## キーワード
Union Find木

## 概要
2種類のクエリuniteとsameが合わせてn個与えられるから題意に沿って結合と判断を行う

## 方針と読解
union find木を実装する。
- 互いに素、なのでn個の独立した木構造を考え、それらをクエリに合わせて結合していくことを考える
- 長さnの配列の添字がそのまま要素になるように配列を作る。
    - それぞれの添字をノード番号とすれば、要素はその親を指す、ということ
- 木の根を遡る関数を用意
- 結合...それぞれの木の根を同じにする。
- 判断...それぞれの木の根が同じかどうかは何する。

union find木は結合と判断はできるが分離はできない不可逆な木構造。問題のバリエーションによってほかにもデータをもたせたりなんかするやつがあるらしい

### 根を遡る
こんな感じ
```python
def root(t):
  if t != arr[t]:
    t = root(arr[t])
  return t
```
### 結合
二つのノードx, yについて、一方の根の参照をもう一方の葉にする。末尾につながって伸びていく感じ
```python
def unite(x, y):
  rootx = root(x)
  rooty = root(y)
  if rooty != rootx:
    arr[rooty] = rootx
```

### 高速化
縦にノードが連なると、最悪の場合O(n)となり、nが大きければ間に合わない。高速化のテクニックは2つ、**木の圧縮**と**ランク付け**。
### 木の圧縮
それぞれのノードの親への参照を、直接根につなげる。これにより縦にノードが連なることはなくなり、いうなれば横に広がる感じになる。**根を遡る際に更新していく**のが賢い
```python
def root(t):
  # 圧縮バージョン
  if t != arr[t]:
    arr[t] = root(arr[t])
  return arr[t]
```

### ランク付け
A, Bの根を共通にするために、一方の末尾に他方の根をつなげる、のではなく、根からA, Bそれぞれが分岐している形になれば高さ（ランク）を抑えることができる、という考え。この場合、高さの高い方に低い方をくっつけると、高い方の高さを超えない（Aの高さ5, Bの高さ3としたときに、Aの根からBの根を生やすのと、逆とでは、それぞれ高さ5, 高さ6になる。図を書けば分かる）

最初にそれぞれの木の高さの配列を0で初期化したものを用意し、同じ高さの木であればくっつけた側の木の高さを+1する、という感じ

```python
def unite(x, y):
  # ランク付け
  rootx = root(x)
  rooty = root(y)
  if rank[rootx] < rank[rooty]:
    arr[rooty] = rootx
  elif rank[rooty] < rank[rootx]:
    arr[rootx] = rooty
  elif rootx != rooty:
    arr[rooty] = rootx
    rank[rootx] += 1
```
（実際に提出するとpythonだと再帰の深さ上限に引っかかるので、あらかじめ上限を増やしておく）
### 高速化まとめ
ふたつの高速化メソッドはそれぞれlog(n)ほど高速化でき、かつ併用できる。併用した場合はアッカーマン関数の逆関数とかいうほぼ定数で終わる処理になるらしい。知らんけど

## 参考
昔書いてたアルゴリズムのメモ帳

## 所感
懐かしい。でもこれ以来まったく応用問題に出会ってない。