## 問題名
Range Minimum Query (RMQ)

## キーワード
Segment tree, セグメントツリー, セグ木, BIT, 遅延評価セグメントツリー, 平衡二分探索木

## 概要
数列と2種類のクエリupdateとfindが与えられるから答える。
- update(ai, x) A[ai]をxに変更する
- find(s, t) A[s, t]の最小値を答える

## 方針と読解
RMQ、なんの略だったかすら忘れる。区間最小値（あるいは最大値）を答える。

RMQの解法としていくつかあるらしい。ここではセグメントツリーでやってみる

（ほかにはSparse Tableなどがあるらしいが、Sparse Tableは途中の値の更新ができないので、この問題ではセグ木がいいらしい)


### セグメントツリーとは
- **区間**に対応づいた完全二分木
- 子は親の半分の長さの**区間**をもつ
- **区間**に基づくクエリに答えるときによく使う
  - **更新が可能**、というのが特徴。
- 応用範囲が広く、これの機能制限版がBITだったり拡張版が遅延評価セグ木や平衡二分探索木だったりするらしい?
  - 最小/最大値に限らずなんかのデータをもたせるとか
  - **区間**に対する操作を受け止める

### データ構造をどう表現するか
木で考えた時、上から下に、左から右に向かって各ノード番号を配列で表す。もとのデータ量以上になる最小の2冪の数ぶん長さがあればいい。すなわち最下段にはN個のノードが、その上には全部でN-1個ある感じで、木全体では**2N-1個**のノードがある

2冪にすることで
- 親ノードへのアクセスがかんたん
- 子ノードへのアクセスがかんたん

というメリットが有る

### 初期化
以上のように表現すると、要素vの数をnとすると、配列の長さは2*n-1で、後ろn個ぶんにvをいれて（配列の最初の方は木で表すと上の方になるので）、前の方はそれらから順次再帰的に埋めていく感じになる

### 親から子, 子から親
今いるノード番号をiとすると
- 親から子 `左側の子 2*i+1 右側の子 2*i+2`
- 子から親 `(i-1)//2`
### 答えるクエリ
最も単純な2つを考える

- update 下の方から上に向かって更新する
- find 上の方から下に向かって探索する

### find?


## 参考
[セグメント木をソラで書きたいあなたに ](http://tsutaj.hatenablog.com/entry/2017/03/29/204841)

# 謎 2019/11/16
find時のここ、なんかなんでこれなの？？
見返したりググったりしたけどやっぱわからん
```python
# なんでlen(arr)じゃなくてamountなんだ？？？？？
def find(a, b, t=0, l=0, r=amount):
    # 範囲外の場合 テキトーな値を返す
    if r <= a or b <= l:
        return INF
    # 覆っている場合 値を返せる
    if a <= l and r <= b:
        return arr[t]
    # 被っている場合 狭める
    lv = find(a, b, 2 * t + 1, l, (l + r) // 2)
    rv = find(a, b, 2 * t + 2, (l + r) // 2, r)
    return min(lv, rv)
```

m = 6とかのときルートノードが見る範囲がamountになるんなら8になるんだけど、これはおかしい
```
                0
      1                   2
  3       4         5           6
7   8   9   10    11    12    13    14 
```
なので、半壊空間で`[0, 8)`だと上記の7までみることになるが、6まででいいはず...


## 所感
謎が解けたらかく